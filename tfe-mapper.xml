<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="yes" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>filter broken prompts</name>
			<script>if (rex.find(matches[1], [[^&lt;]])) then
  -- echo(' &lt;- prompt\n')
  raiseEvent(njs50.scanner.events.PROMPT)
 end</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^(?:&lt;[^&gt;]+&gt;)?([^&lt;].*)$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>scanner</name>
				<script>-- failing on: &lt;799hp 1304e 190mv 190wm 97384212xp NE&gt;      [Here] : Mohoonay, a tall, well-built horse, Grehild

      -- [Here] : Grehild, Darius, Affenaut, Uduvrin, Alavela, a Medienne Knight,
               -- a knight's heavy charger
        -- east : a Medienne guard

-- You see nothing in the vicinity.
if (matches[1] == 'You see nothing in the vicinity.') then
	
		-- echo(' &lt;-- reset exits')
  	njs50.scanner.resetExits();
		cecho(' &lt;- &lt;green&gt;SCANNER: &lt;white&gt;clear\n')
		raiseEvent(njs50.scanner.events.SCAN_PROCESSED)
		
else 

  local direction = matches[2]:gsub('^%s+','')
  
  if (direction ~= '' or njs50.scanner.scan_in_progress) then
  
    if (matches[3] == 'darkness') then
      njs50.scanner.scannedLine(direction, 'darkness')
      cecho('\n&lt;orange&gt;SCANNER: &lt;white&gt;should create better light before continuing\n')    
    else			
  		
      -- sometimes scan is jammed in with other content. scan lines are always indented with spaces
      -- so matches[2] should either be a bunch of space or a direction
      if (matches[3] ~= '' and matches[2] ~= '') then
  		  njs50.scanner.scannedLine(direction, matches[3])
      else
        -- scanning done, no need to wait for prompt (in case there is other junk before it)
        njs50.scanner.endScan()        
      end
  	 	
    end 
  
  end
		
 end -- end (if you see nothing)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\s+(north|east|south|west|up|down|\[Here\])\s+:\s+(.+)$</string>
					<string>^\s+((?:far|north|east|south|west|up|down) (?:north|east|south|west|up|down))\s+:\s+(.+)$</string>
					<string>You see nothing in the vicinity.</string>
					<string>^(\s*)(.*)$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>2</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>rescan if something died</name>
				<script>if (group.leader == player.name) then
  send('queue level &amp; queue scan')
else
  cecho('&lt;green&gt;&lt;-- skipped scan due to not being leader\n')
end

--       A fair gnomish lass is DEAD!!</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\s+(An?|The) (.*) is DEAD!!</string>
					<string>^(An?|The) (.*) blindly flees </string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>You can't do that while mounted.</name>
				<script>njs50.onNextEvent(tfe.events.ROOM_CHANGED, function ()
	send('mount')
end)
send('dismount')
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You can't do that while mounted.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>The x to the y is closed.</name>
				<script>disableTrigger('The x to the y is closed.')

local vic = njs50.dotCase(njs50.toMurderString(matches[2]))

-- convert north gate etc -&gt; gate
vic = rex.gsub(vic, '(north|east|south|west|down|up|above|below).', '') 

local dir = matches[3]

send('move beam &amp; pull lever &amp; turn crank &amp; pull cord &amp; trace rune')
send('unlock ' .. vic .. ' &amp; unlock ' .. dir)
send('open ' .. vic .. ' &amp; open ' .. dir)
send('knock ' .. vic .. ' &amp; knock ' .. dir)
send('pound ' .. vic .. ' &amp; pound ' .. dir)

tempTimer(2, function () send('scan') end, 'scan after attempting to open')

tempTimer(1, function ()
	enableTrigger('The x to the y is closed.')
end, 'reenable closed door trig')
-- 
-- if (tfe.speedwalking) then
	-- send(tfe.lastMoveDirection)
-- end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^The (.+) to the (.+) (is|are) closed.</string>
					<string>^Perhaps you should open the (double) (doors)</string>
					<string>^The (.*) (below|above) you (is|are) closed.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>no exit - use special exit</name>
				<script>disableTrigger('no exit - use special exit')

local exit = matches[2]

if (exit == 'below') then exit = 'down' end
if (exit == 'above') then exit = 'up' end



local exits = getRoomExits(tfe.roomInfo.vnum)
local specialExits = getSpecialExits(tfe.roomInfo.vnum)

if (exits and specialExits) then

  local targetRoom = exits[exit]
  
  if (targetRoom and specialExits[targetRoom]) then
    for command, idx in pairs(specialExits[targetRoom]) do 
      send(command)
    end
  else
    cecho('\n&lt;green&gt;MOVE: &lt;white&gt;failed to go ' .. exit .. '... you can use "map exit [n|e|s|w|u|d] &lt;cmd&gt;" to add a special exit \n' )
  end

else
  cecho('\n&lt;green&gt;MOVE: &lt;white&gt;failed to go ' .. exit .. '... you can use "map exit [n|e|s|w|u|d] &lt;cmd&gt;" to add a special exit \n' )
end

tempTimer(1, function ()
	enableTrigger('no exit - use special exit')
end, 'reenable closed door trig')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You see no exit to the (.*)\.</string>
					<string>^You see no exit (.*) you\.</string>
					<string>^The .+ to the (.+) (is|are) closed.</string>
					<string>^The .* (below|above) you (is|are) closed.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>tell me path x to y</name>
				<script>local vic = matches[2]
local src = matches[3]

local dest = matches[4]


local path = tfe.getPath(src, dest)

if (path.error) then
  
  cecho('\n\n&lt;red&gt;TFE MAP:&lt;white&gt; ' .. path.error .. '\n\n')
  send('tell ' .. vic .. ' ' .. path.error)

else

  send('tell ' .. vic .. ' to go from ' .. path.from .. ' to ' .. path.to .. ' do:')
  send('tell ' .. vic .. ' speed ' .. path.path)
  
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^([A-Za-z]+) tells you:\s*"path (.+) to (.+?)\??"$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>tell me locations</name>
				<script>local vic = matches[2]


local locStr = ''
for idx, loc in ipairs(table.keys(tfe.locations)) do
  
  if (idx % 25 == 1 and locStr ~= '') then
    send('tell ' .. vic .. ' I know about: ' .. locStr)
    locStr = ''
  end
  
  if (idx % 25 ~= 1) then locStr = locStr .. ', ' end
  
  locStr = locStr .. loc

end

if (locStr ~= '') then
  send('tell ' .. vic .. ' I know about: ' .. locStr)
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^([A-Za-z]+) tells you:\s*"locations"$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<Alias isActive="yes" isFolder="no">
			<name>map reset</name>
			<script>local commands = {
  
  reset = function(thing)
    if (thing == 'area') then
      tfe.deleteCurrentMapArea()
    end
  end,
  
  update = njs50.update_mapper,
  
}

if (commands[matches[2]]) then
  commands[matches[2]](matches[3])
else
  cecho('&lt;red&gt;TFE MAP: &lt;white&gt;unknown command - ' .. matches[2] .. '\n\n')
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^map (reset|update)\s?(.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>go</name>
			<script>local dest = matches[2]

tfe.locations = tfe.locations or {}

local rnum = tfe.locations[dest] or dest

if (type(rnum) == 'string' and rnum:match([[^%d+$]])) then
  
  rnum = tonumber(rnum)
  
end

if (type(rnum) == 'number' and roomExists(rnum)) then

	cecho('&lt;green&gt;TFE MAP:&lt;white&gt; going to ' .. getRoomName(rnum) .. '\n')
 
  local endCmd = matches[3]

	tfe.gotoRoom(rnum, { 
    callback = function () 
  		if (endCmd) then
  			expandAlias(endCmd)
  		end
  	end
  })
	
else
	cecho('\n&lt;red&gt;TFE MAP:&lt;white&gt; Invalid speed walk location\n')
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^go (\S+)\s?&amp;?\s?(.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>path</name>
			<script>local src = matches[2]
local dest = matches[3]


local path = tfe.getPath(src, dest)

if (path.error) then
  
  cecho('\n\n&lt;red&gt;TFE MAP:&lt;white&gt; ' .. path.error .. '\n\n')

else

  cecho('&lt;green&gt;TFE MAP:&lt;white&gt; to go from ' .. path.from .. ' to ' .. path.to .. ' is: speed ' .. path.path .. '\n')
  
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^path (\S+)\s(\S+)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>^(stop|pause|resume)$</name>
			<script>
local commands = {
  stop = tfe.speedwalkStop,
  pause = tfe.speedwalkPause,
  resume = tfe.speedwalkResume,
}

commands[matches[2]]()</script>
			<command></command>
			<packageName></packageName>
			<regex>^(stop|pause|resume)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>map - special exit</name>
			<script>local dir = matches[2]
local cmd = matches[3]

display(dir, cmd)

-- cancel an existing special exit if the move failed (maybe we were in the wrong room)
if (dir ~= 'cancel') then
  
  if (tfe.pendingSpecialExit) then
    tfe.pendingSpecialExit()
  end
  
  tfe.pendingExit = {
    direction = tfe.consts.reverse_dirs[tfe.consts.exitmap[dir]],
    vnum = tfe.roomInfo.vnum
  }
   
  
  tfe.pendingSpecialExit = njs50.onNextEvent(tfe.events.ROOM_CHANGED, function () 
  
    addSpecialExit(tfe.pendingExit.vnum, tfe.roomInfo.vnum, cmd)
    setExit(tfe.pendingExit.vnum, tfe.roomInfo.vnum, dir)
    setExitWeight(tfe.pendingExit.vnum, dir, 3)
      
    tfe.pendingSpecialExit = nil
    tfe.pendingExit = nil
    
    -- display(tfe.previousRoomInfo.vnum, 'to', tfe.roomInfo.vnum, cmd)
  
  end)
  
  cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; adding special exit!\n')
  cecho('&lt;green&gt;TFE MAP: &lt;white&gt; type "map exit cancel" to cancel if the command fails to change the room!\n')
  send(cmd)

else

  if (tfe.pendingSpecialExit) then
    tfe.pendingSpecialExit()
  end
  
  tfe.pendingExit = nil
  cecho('\n&lt;yellow&gt;TFE MAP: &lt;white&gt; cancelled adding special exit!\n')

end</script>
			<command></command>
			<packageName></packageName>
			<regex>^map exit (n|e|s|w|u|d|in|out|cancel) ?(.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>map - manual connect numbered to current</name>
			<script>-- not sure we need this anymore, only really useful for retroactively connecting things

local dir = matches[2]
local room2 = tonumber(matches[3])
local room1 = tfe.roomInfo.vnum
local cmd = matches[4] or ''

-- we may need to create the current room if it is orphaned in the zone from the prev room
if not roomExists(room1) then

  local areaId = tfe.getAreaID(tfe.roomInfo)
   
  local x,y,z = tfe.getRoomCoordinatesByExit(room2, tfe.consts.exitmap[dir])
  
  -- echo('\new location is: ' .. tostring(x) .. ', ' .. tostring(y) .. ', ' .. tostring(z) .. ')\n')
      
    addRoom(room1)
	  setRoomArea(tfe.roomInfo.vnum, areaId);
	  setRoomName(tfe.roomInfo.vnum, tfe.roomInfo.name)
	  setRoomCoordinates(tfe.roomInfo.vnum, x, y, z)  
    centerview(tfe.roomInfo.vnum)
    
    cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; added new room - ' .. dir .. ' from ' .. tfe.previousRoomInfo.name .. '\n')

end




if (roomExists(room1) and roomExists(room2)) then
  
  setExit(room2, room1, dir)
  
  if (cmd) then        
    addSpecialExit(room2, room1, cmd) 
    setExitWeight(room2, dir, 3) -- prioritize special exit
  end
  
  setExit(room2, room1, dir)
  centerview(room1)
    
  cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; connecting existing rooms!\n')
  
else

  cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt; room doesn\'t exist in map!: ' .. tostring(room2) .. '\n')

end
</script>
			<command></command>
			<packageName></packageName>
			<regex>^map add (n|e|s|w|u|d|in|out) (\d+) ?(.*)?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>map - connect current room with previous</name>
			<script>

local dir = matches[2]
local cmd = matches[3]

local room1 = tfe.roomInfo.vnum
local room2 = tfe.previousRoomInfo.vnum


  -- we may need to create the current room if it is orphaned in the zone from the prev room
  if not roomExists(room1) then
  
    local areaId = tfe.getAreaID(tfe.roomInfo)
     
    local x,y,z = tfe.getRoomCoordinatesByExit(room2, tfe.consts.exitmap[dir])
    
    -- echo('\new location is: ' .. tostring(x) .. ', ' .. tostring(y) .. ', ' .. tostring(z) .. ')\n')
        
      addRoom(tfe.roomInfo.vnum)
		  setRoomArea(tfe.roomInfo.vnum, areaId);
  	  setRoomName(tfe.roomInfo.vnum, tfe.roomInfo.name)
  	  setRoomCoordinates(tfe.roomInfo.vnum, x, y, z)  
      centerview(tfe.roomInfo.vnum)
      
      cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; added new room - ' .. dir .. ' from ' .. tfe.previousRoomInfo.name .. '\n')
  
  end




if (roomExists(room1) and roomExists(room2)) then
  
  setExit(room2, room1, dir)
  
  if (cmd) then        
    addSpecialExit(room2, room1, cmd) 
    setExitWeight(room2, dir, 3) -- prioritize special exit
  end
  
  setExit(room2, room1, dir)
  centerview(room1)
    
  cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; connecting existing rooms!\n')
  
else

  cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt; room doesn\'t exist in map!: ' .. tostring(room2) .. '\n')

end
</script>
			<command></command>
			<packageName></packageName>
			<regex>^map connect (n|e|s|w|u|d|in|out) ?(.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>lw</name>
			<script>
local areas = getAreaTable()  
  
local area1 = areas['The Ways : 51']
local area2 = areas['The Ways : 52']
  
-- display(area1, area2)


local exits = table.union(getAreaExits(area1, true), getAreaExits(area2, true))

-- display(exits)

cecho('\n')

for idx, exit in pairs(exits) do

  
  if (not exit.up) then
    
    cecho('room #' .. tostring(idx))
    
    for exitDir, rnum in pairs(exit) do
      cecho(' ' .. exitDir .. ': ' .. rex.gsub(getRoomAreaName(getRoomArea(rnum)), [[: \d+$]], ''))
    end 
    
    cecho('\n')
    
  end
  
end



</script>
			<command></command>
			<packageName></packageName>
			<regex>^lw$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>map - load</name>
			<script>-- "https://raw.githubusercontent.com/njs50/njs50-plev/master/njs50-map.dat"

local URL = matches[2]

uninstallPackage("generic_mapper")

if not URL:ends("dat") then

  cecho("&lt;red&gt;INSTALL: &lt;white&gt;map url doesn't appear to be valid, should be something like:\n") 
  cecho("&lt;white&gt;https://raw.githubusercontent.com/njs50/njs50-plev/master/njs50-map.dat\n")

else
  
  njs50.onNextEvent("sysDownloadDone", function (_, f)
    
    local loadOK = loadMap(f)
    
    if not loadOK then
     cecho("&lt;red&gt;INSTALL: &lt;white&gt;Couldn't load - was the mapper open? :(\n")
    else
      cecho("&lt;green&gt;INSTALL: &lt;white&gt;Loaded fine!\n")
    end
    os.remove(f)
  
  end)
  
  cecho("&lt;green&gt;MAP INSTALL: &lt;white&gt;downloading - " .. URL .. "\n")

  downloadFile(getMudletHomeDir().. "/njs50-map.dat", URL)
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^map load (.*)$</regex>
		</Alias>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>configuration</name>
			<packageName></packageName>
			<script>njs50 = njs50 or {}

njs50.config = {
  rewrite_scan = false, -- make scan results clickable (move or attack)
}






njs50.update_mapper = function ()

  local URL = "https://raw.githubusercontent.com/njs50/tfe-mapper/master/tfe-mapper.xml"
  
  njs50.onNextEvent("sysDownloadDone", function (_, f)
    if not f:find("tfe-mapper", 1, true) then 
      return 
    end
    uninstallPackage("tfe-mapper")
    installPackage(f)
    os.remove(f)
    cecho("&lt;lime_green&gt;Package installed!\n") 
  end)
  
  downloadFile(getMudletHomeDir()..(URL:ends("xml") and "/tfe-mapper.xml" or "/tfe-mapper.zip"), URL)

end

njs50.install_color_theme = function ()



end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>njs50 common</name>
			<packageName></packageName>
			<script>njs50 = njs50 or {}

njs50.onNextEvent = function (evt, callback)

	if not evt then
		cecho('\n\n&lt;red&gt;Next Event: &lt;white&gt;no event defined!!!\n\n')
		error()
	end


	local handlerId = nil
	local cb2 = callback

	local cb = function (evt, args)
		killAnonymousEventHandler(handlerId)
		cb2(evt, args)
	end

	handlerId = registerAnonymousEventHandler(evt, cb, true)

	-- cecho('\n&lt;green&gt;registering self destruct event: ' .. evt .. ' : ' .. tostring(handlerId) .. '\n')

	return function ()
		-- cecho('\n&lt;orange&gt;destructing handler: ' .. evt .. ' : ' .. tostring(handlerId) .. '\n')
		killAnonymousEventHandler(handlerId)
	end

end

njs50.tablelength = function(T)
  local count = 0
  for _ in pairs(T) do count = count + 1 end
  return count
end

njs50.timedTempTrigger = function (timeout, maxTriggerCount, pattern, callback, failcallback)

	local ofcb = failcallback
	local ocb = callback
  
  local fcb
  local cb
  local tempTimerId
  local triggerId
  maxTriggerCount = maxTriggerCount or 1
  
  local count = 0

	cb = function ()
		fcb = nil;
    ofcb = nil;
    count = count + 1
    if (count &gt;= maxTriggerCount) then
      killTrigger(triggerId)
    end
    -- echo('\n -- killing temp timed trigger timer\n')
    killTimer(tempTimerId)
		if (ocb) then
			ocb()
		end
	end
  
  fcb = function()
    cb = nil;
    ocb = nil;
    killTrigger(triggerId)
    if (ofcb) then
      ofcb()
    end
  end

	triggerId = tempRegexTrigger(pattern, cb, maxTriggerCount)

	tempTimerId = tempTimer(timeout, function ()
		-- echo('\n -- killing temp timed trigger\n')
	   fcb()
	end, 'timed temp trigger')

	return {triggerId = triggerId, timerId = tempTimerId}

end

njs50.killTimedTempTrigger = function (oTT)
  killTimer(oTT.timerId)
  killTrigger(oTT.triggerId)
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>formatters</name>
			<packageName></packageName>
			<script>common = common or {}

-- can add items to override from shortening if they mess up gear swapping
common.itemShortenOverride = common.itemShortenOverride or {}
common.itemShortenOverride['darkgem'] = 'darkgem'
common.itemShortenOverride['darklight'] = 'darklight'
common.itemShortenOverride['shadowbox'] = 'shadowbox'

common.consoleMessage = function(console, message, statusColor, excludeAll)

  local color = 'green'

  if (statusColor) then
    color = statusColor
  end

  common.chatConsole:cecho(console, '&lt;' .. color .. '&gt;' .. getTime(true, "hh:mm:ss") .. ': &lt;white&gt;' .. message .. "\n", excludeAll)
end


common.escape = function (str)
  str = rex.gsub(str, [[\\]], '\\\\')
  return str
end


common.formatElapsedTime = function (time)

	local ts = '';

	if (not time) then
		return '0 seconds'
	end

	local hrs = 0
	local mins = 0
	local secs = 0

	if (time &gt;= 3600) then
		hrs = math.floor(time / 3600)
		time = time - (hrs * 3600)
		ts = ts .. tostring(hrs) .. ' hrs, '
	end


	if (time &gt;= 60 or hrs &gt; 0) then
		mins = math.floor(time / 60)
		time = time - (mins * 60)
		ts = ts .. tostring(mins) .. ' mins, '
	end

	secs = math.floor(time)
	time = time - secs
	ts = ts .. tostring(secs) .. ' seconds'


	return ts

end

common.getNumber = function (text)

	local wordToNumberData = {
  	a = 1,
  	an = 1,
  	the = 1,
		one = 1,
		two = 2,
		three = 3,
		four = 4,
		five = 5,
		six = 6,
		seven = 7,
		eight = 8,
		nine = 9,
		ten = 10,
		eleven = 11,
		twelve = 12,
		thrirteen = 13,
		fourteen = 14,
	}

	local numTxt = rex.match(text, [[^\S+]])

	if (numTxt) then
		return wordToNumberData[string.lower(numTxt)] or 1
	else
		-- either it's more than 14 or a proper noun. i.e Stinky (your mount
		return 1
	end

end

common.cleanGmcpTarget = function(string)
  return common.dotCase(common.toMurderString(rex.gsub(rex.gsub(string, [[^\d+\.]], ''), [[\.]], ' ')))
end

common.dotCase = function(string)

	if (not string or string == '') then
		return ''
	end
	return rex.gsub(string, [[(?i)\b(the|or|an|a|of|with|and|A|An|The) ]], ''):gsub(' ', '.')
end


common.itemSanitize = function(string)

	if (not string or string == '') then
		return ''
	end



	string = rex.gsub(string, [[(enchanted |empty, |flaming, frost-covered |flaming |labeled |empty |\s\+\d)]], '')

  if (string ~= 'frost-covered ring') then
    string = rex.gsub(string, [[frost-covered ]], '')
  end

  return string

end


common.itemShorten = function(item)

  item = common.dotCase(common.itemSanitize(item))
  
  if (common.itemShortenOverride[item]) then
    return common.itemShortenOverride[item]
  else
  
    return rex.gsub(	rex.gsub(item,"'(.*)'",'%1'),
      	'([^.][^.][^.][^.]?)[^.]+',
      	'%1'
    )
  end

end

common.commaCase = function (str)
    local extra = #str%3
    if string.sub(str,1,1) == "-" then
        if extra == 0 then
            extra = 3
        else
            extra = extra + 1
        end
    end
    local result = ""
    if extra &gt; 0 then
        result = string.sub(str,1,extra)
        str = string.sub(str,extra+1)
    end
    for w in string.gmatch(str,"%d%d%d") do
        result = result .. "," .. w
    end
    return result:gsub([[^,?]],'')
end


common.toMurderString = function (victim)

	-- remove any articles etc
	victim = rex.gsub(victim, [[(?i)\b(a|an|the|good|evil|The|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen)\s]], '')

	-- turn elves back into elf, dwarves etc
	victim = rex.gsub(victim, [[ves$]], 'f')

	-- turn women back to womans, guardsmen to guardsman
	victim = rex.gsub(victim, [[(\w+)men\b]], '%1man')
	-- drop i from end (plurals like homonculi
  
  local ignoreTerminalI = {
    yeti = true,
    ['mammoth yeti'] = true,
  }
  
  local specialCases = {
    mice = 'mouse'
  }

  if (specialCases[victim]) then
    victim = specialCases[victim]
  end

  if (not ignoreTerminalI[victim]) then
	 victim = rex.gsub(victim, [[i( |$)]], '%1')
  end

	 -- turn mercenaries back into mercanary
	victim = rex.gsub(victim, [[ies$]], 'y')

	-- dump any s's or es's on the end of a plural
	-- west : two greater cyclopses, vs a greater cyclops
	-- drudges should go to drudge tho...
	if (rex.find(victim, [[ses\b]])) then
		victim = rex.gsub(victim, [[ses\b]], 's')
	elseif (rex.find(victim, [[es\b]])) then
    -- cockroaches -&gt; cockroach
		victim = rex.gsub(victim, [[es\b]], '')
	else
		victim = rex.gsub(victim, [[('?s'?)\b]], '')
	end

	-- dump any random commas
	victim = rex.gsub(victim, [[,]], '')

	-- kill any parts less than 3 charaters

	victim = rex.gsub(victim, [[(^|\.|\s)\S\S?(\s|\.|$)]], '%1%2')

	-- kill any extra whitepsace or multiple .'s
	victim = rex.gsub(victim, [[(\s\s+|\.\.+)]], ' ')
	victim = string.trim(victim)

	-- kill any . at start or end.
	victim = rex.gsub(victim, [[^\.]], '')
	victim = rex.gsub(victim, [[\.$]], '')

	return victim

end

common.tableToString = function (table)
  
  local list = ''
  
  for idx, val in ipairs(table) do
    
    list = list .. val .. ', '
  
  end
  
  list = list:gsub(', $', '')
  
  return list
  
end

common.getAreaName = function(roomId)
  local areaId = getRoomArea(roomId)
  local areaName = getRoomAreaName(areaId)
  
  return rex.gsub(areaName, [[\s+:\s+\d+$]], '')
  
end


-- copy these to njs50 scope for weird historical reasons
njs50.formatElapsedTime = common.formatElapsedTime
njs50.getNumber = common.getNumber
njs50.cleanGmcpTarget = common.cleanGmcpTarget
njs50.dotCase = common.dotCase
njs50.itemSanitize = common.itemSanitize
njs50.commaCase = common.commaCase
njs50.toMurderString = common.toMurderString
njs50.itemShorten = common.itemShorten
njs50.tableToString = common.tableToString
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>scanner</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

njs50.scanner = njs50.scanner or {}

njs50.scanner.events = {		
	SCAN_PROCESSED = 'SCANNER:rooms_scanned',
  PROMPT = 'SCANNER:prompt seen',
}

njs50.scanner.resetExits = function ()
	njs50.scanner.exits = {}
end


njs50.scanner.resetScanner = function ()
	njs50.scanner.scan_in_progress = false
  njs50.scanner.currentDirection = nil
	if (njs50.scanner.cancel_scan_in_progress) then
		njs50.scanner.cancel_scan_in_progress()
		njs50.scanner.cancel_scan_in_progress = nil
	end
	njs50.scanner.resetExits()
end

njs50.scanner.endScan = function()
  if (njs50.scanner.cancel_scan_in_progress) then
    njs50.scanner.cancel_scan_in_progress()
    njs50.scanner.cancel_scan_in_progress = nil
  end
  njs50.scanner.currentDirection = nil
  njs50.scanner.scan_in_progress = false
  cecho(' &lt;- &lt;green&gt;SCANNER: &lt;white&gt;scan ended\n')

  -- display(njs50.scanner.exits)
	raiseEvent(njs50.scanner.events.SCAN_PROCESSED, njs50.scanner.exits)
end

njs50.scanner.scannedLine = function (direction, mobs)  		
	
	if (not njs50.scanner.scan_in_progress) then
    -- cecho('\n&lt;green&gt;SCANNER: &lt;white&gt;scan started\n')
		njs50.scanner.resetExits();			
		njs50.scanner.scan_in_progress = true
    -- in case for some reason there isn't a blank line after the scan
    -- stop scanning ont the next prompt
		njs50.scanner.cancel_scan_in_progress = njs50.onNextEvent(njs50.scanner.events.PROMPT, njs50.scanner.endScan)
	end
  
	
  if (direction ~= "") then
    njs50.scanner.processingExit = direction
    
    -- sometimes two scans come in back to back with no gap. gotta reset direction whenever it is present
    -- i.e :
    -- south: yeti
    -- south: yeti
    -- should not = 2 yetis south
    njs50.scanner.exits[direction] = {}
    
    if (direction ~= '[Here]') then
      if njs50.config.rewrite_scan then
        selectString(direction,1)
        setUnderline(true)
        setLink([[send("]]..direction..[[")]], 'move ' .. direction)
        resetFormat()
      end
    end
    
  else
     direction = njs50.scanner.processingExit
  end
  
  njs50.scanner.exits[direction] = njs50.scanner.exits[direction] or {}
  
  -- convert strings to individual mobs
  -- nb: commas make this difficult as they might be in a mob name and not a seperator
  -- i.e. 
  
  
  local nubs = {}
  for s, c, r in rex.split(mobs, [[, (?=a |an |the |[A-Z]|two |three |four |five |six |seven |eight |nine |ten |eleven |twelve | thirteen |fourteen |fifteen )]]) do
    table.insert(nubs, s)
  end
  
  -- convert mobs to attack strings with counts
  for idx, mobString in pairs(nubs) do
    
    local mobRecord
    local ks = njs50.dotCase(njs50.toMurderString(mobString))
    local count = njs50.getNumber(mobString)
    
    -- check to see if there is already a mob with this name
    -- i.e east: a Medienne Knight, a Medienne Knight
    for idx, record in pairs(njs50.scanner.exits[direction]) do
      if (record.killString == ks) then
        mobRecord = record
        break;
      end
    end
    
    if (mobRecord == nil) then 
      mobRecord = { 
        raw = mobString, 
        killString = ks, 
        count = count 
      }
      table.insert(njs50.scanner.exits[direction], mobRecord)
    else
      mobRecord.count = mobRecord.count + count
    end
      
    if njs50.config.rewrite_scan then  
      selectString(mobRecord.raw,1)
      setUnderline(true)
      setLink([[send("]].. direction ..[[ &amp; k ]] .. mobRecord.killString .. [[")]], direction .. ' &amp; k ' .. mobRecord.killString)
      -- replace('xxxx')
      resetFormat()
    end
    
  end
	
end

</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>tfe mapper</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
mudlet = mudlet or {};
mudlet.mapper_script = true



tfe = tfe or {}

tfe.events = {
  ROOM_CHANGED = 'tfe mapper: room found',
  WALK_COMPLETE = 'tfe mapper: speedwalk complete',
}




-- bleh 1-16 and 257-272 are reserved
tfe.environment = {
  
  Air = 41,
  ["Magical Cloud"] = 59,
  
  
  ["Dark Bamboo"] = 47, 
  ["Bamboo Forest"] = 42,
  Forest = 53,
  Jungle = 56,
  Rainforest = 25,
  Tree = 34, 
   
  Trail = 33, 
  ["Jungle Trail"] = 57,
  ["Forest Path"] = 54,
  
  Dirt = 49,

  ["Compost Zone"] = 46,
  
  Dump = 51,
  Pudding = 24,
  
  Path = 23,
  Road = 27,
  ["Town Street"] = 32,
    
  Tundra = 35, 
  Field = 52,
  
  Beach = 43,
  Desert = 48,
  ["White Sand"] = 39,
   
  Cave = 45,
 
  Lava = 58,
  
  Hills = 55,

  Bridge = 44,
  Mountain = 20,
  
  Underwater = 36,
  Water = 38,
  River = 26,
  ["Ocean Water"] = 22,

  Swamp = 31,
  
  Shallows = 29,
  ["Dry Riverbed"] = 50,
  
  Shipboard = 30,
  WoodenBoards = 40,
  
  Room = 28,
  
  Nondescript = 21,
  Void = 37,
  
}


-- to see color optiosn
-- lua showColors(3)

tfe.environmentColor = {
  
  Air = 'deep_sky_blue',
  ["Magical Cloud"] = 'light_sky_blue',
  
  
  ["Dark Bamboo"] = 'dark_green', 
  
  ["Bamboo Forest"] = 'forest_green',
  Forest = 'forest_green',
  Jungle = 'forest_green',
  Rainforest = 'forest_green',
  Tree = 'lime_green',
   
  Path = 'khaki', 
  Trail = 'khaki', 
  ["Jungle Trail"] = 'khaki', 
  ["Forest Path"] = 'khaki', 
  
  Dirt = 'saddle_brown', 

  ["Compost Zone"] = 'saddle_brown',
  
  Dump ='saddle_brown',
  Pudding = 'saddle_brown',
  
  
  
  Road = 'dark_khaki',
  ["Town Street"] = 'dark_khaki',
    
  Tundra = 'wheat', 
  Field = 'wheat', 
  
  Beach = 'navajo_white',
  Desert = 'navajo_white',
  ["White Sand"] = 'navajo_white',
   
  Cave = 'dark_slate_gray',
 
  Lava = 'orange_red',
  
  Hills = 'dark_olive_green',

  Bridge = 'dark_olive_green',
  Mountain = 'dark_olive_green',
  
  Underwater = 'navy_blue',
  
  Water = 'dodger_blue',
  River = 'dodger_blue',
  ["Ocean Water"] = 'dodger_blue',

  Swamp = 'light_sky_blue',
  
  Shallows = 'light_sky_blue',
  
  ["Dry Riverbed"] = 'light_steel_blue',
  
  Shipboard = 'dark_khaki',
  WoodenBoards = 'dark_khaki',
  
  Room = 'beige',
  
  Nondescript = 'beige',
  
  Void = 'dark_slate_grey',
  
}

for terrain, color in pairs(tfe.environmentColor) do
  local r, g, b = unpack(color_table[color])
  setCustomEnvColor(tfe.environment[terrain], r, g, b, 255)
end


local shortSpeedWalkTimerId

tfe.startShortSpeedWalkTimer = function ()

	-- clear any existing timer
	tfe.clearShortSpeedWalkTimer()


	-- give us 5 seconds to move...
	shortSpeedWalkTimerId = tempTimer(5, function ()
		shortSpeedWalkTimerId = nil
		cecho('\n&lt;yellow&gt;TFE MAP: &lt;white&gt;5 seconds without room change!!! - updating path...\n')
    send('queue scan')
    tempTimer(2, function()
  		tfe.rerouteSpeedwalk()
      tfe.speedWalkStep()
    end)
	end)


end

tfe.clearShortSpeedWalkTimer = function()
	if (shortSpeedWalkTimerId) then
		killTimer(shortSpeedWalkTimerId)
	end
	shortSpeedWalkTimerId = nil
end

tfe.speedwalkPause = function ()
  if (tfe.speedwalking) then
    tfe.speedwalking.paused = true
    cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;speedwalking paused\n')
  else
   cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;not currently speedwalking\n')
  end
end

tfe.speedwalkResume = function ()
  if (tfe.speedwalking) then
    tfe.speedwalking.paused = nil
    cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;speedwalking resumed\n')
    tfe.speedWalkStep()
  else
     cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;not currently speedwalking\n')
  end
end

tfe.speedwalkStop = function ()
 
 if (tfe.speedwalking) then
    tfe.clearShortSpeedWalkTimer()
    -- clear any room change watcher if it exists
    if (tfe.speedwalking.roomChangeWatcher) then
      tfe.speedwalking.roomChangeWatcher()
      tfe.speedwalking.roomChangeWatcher = nil
    end
    
    tfe.speedwalking = nil
    cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;speedwalking stopped\n')
  else
     cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;not currently speedwalking\n')
  end
  
end


tfe.speedWalkStep = function ()
  
  tfe.clearShortSpeedWalkTimer()
  -- clear any room change watcher if it exists
  if (tfe.speedwalking and tfe.speedwalking.roomChangeWatcher) then
    tfe.speedwalking.roomChangeWatcher()
    tfe.speedwalking.roomChangeWatcher = nil
  end

  if (tfe.speedwalking) then
    
    
    -- check we are not off course...
    local nextStep = tfe.getNextStep()

    if (nextStep == nil) then
            
      -- clearing current walk before callback in case cb creates new path      
  
      
      -- we made it to the end. call the callback if it exists
      cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;at destination\n')
      if (tfe.speedwalking.options and tfe.speedwalking.options.callback) then
        local cb = tfe.speedwalking.options.callback
        tfe.speedwalking = nil
        raiseEvent(tfe.events.WALK_COMPLETE)
        cb()
      else  
        tfe.speedwalking = nil
        raiseEvent(tfe.events.WALK_COMPLETE)
      end
      
      
    
    else
    
      -- we are where we should be. send a move etc
      
      if (not tfe.speedwalking.paused) then
      
        -- setup a single event watcher for a room change
        tfe.speedwalking.roomChangeWatcher = njs50.onNextEvent(tfe.events.ROOM_CHANGED, function() 
          -- step completed. do next step    
          tfe.speedWalkStep()
        end)
        
        tfe.startShortSpeedWalkTimer()

        -- send command
        if(nextStep and nextStep ~= '') then
          send( nextStep )    
          tfe.advanceStepPosition()
        else
          cecho('\n\n&lt;red&gt;TFE MAP: &lt;white&gt;unsure  how to progress (missing special exit?)\n')
        end
        
      else
        cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;speedwalking paused\n')
      end
    
    end
      
      
    
    
  else
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;unable to update path., destination not in map\n')
  end

end

tfe.getNextStep = function (reverse)

  -- not currently walking anywhere
  if (not tfe.speedwalking) then
    return nil
  end
  

  -- check if we are lost and need to reroute...  
  if (tostring(tfe.roomInfo.vnum) ~= tfe.speedwalking.path[tfe.speedwalking.pathPosition]) then
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;we are off the designated path, recalculating in 5 seconds\n')
    send('queue scan')
    tfe.rerouteSpeedwalk()
    return ''
  end  
  
  -- at destination
  if (not reverse and tostring(tfe.roomInfo.vnum) == tfe.speedwalking.destination) then
    return nil
  end
  
  -- at start and reversed
  if (reverse and tfe.speedwalking.pathPosition == 1) then
    return nil
  end
   
  if (not reverse) then

    return tfe.consts.exitmap[ tfe.speedwalking.directions[tfe.speedwalking.pathPosition] ] or tfe.speedwalking.directions[tfe.speedwalking.pathPosition]      
  
  else
  
    local specialExits = getSpecialExits(tfe.roomInfo.vnum)
    local targetRoom = tonumber(tfe.speedwalking.path[tfe.speedwalking.pathPosition - 1])
    
    local cmd = ''
    
    if (specialExits and specialExits[targetRoom]) then
      for command, idx in pairs(specialExits[targetRoom]) do 
        cmd = cmd .. command .. ' &amp; '
      end
      cmd = cmd:gsub([[ &amp; $]], '')
      
    else
      cmd = tfe.consts.reverse_dirs[ tfe.consts.exitmap[ tfe.speedwalking.directions[tfe.speedwalking.pathPosition - 1] ] ]
    end
    
    return cmd  
  
  end
  
end

tfe.getNextDirection = function (reverse)


  -- not currently walking anywhere
  if (not tfe.speedwalking) then
    return nil
  end
   
    -- check if we are lost and need to reroute...  
  if (tostring(tfe.roomInfo.vnum) ~= tfe.speedwalking.path[tfe.speedwalking.pathPosition]) then
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;we are off the designated path, recalculating in 5 seconds\n')
    send('queue scan')
    tfe.rerouteSpeedwalk()
    return nil
  end
   
  -- at destination
  if (not reverse and tostring(tfe.roomInfo.vnum) == tfe.speedwalking.destination) then
    return nil
  end
  
  -- at start and reversed
  if (reverse and tfe.speedwalking.pathPosition == 1) then
    return nil
  end

  
  local nextpos = tfe.speedwalking.pathPosition
    
  if (reverse) then
    nextpos = nextpos - 1
  else
    nextpos = nextpos + 1
  end
  
  local target = tonumber(tfe.speedwalking.path[nextpos])
  local exits = getRoomExits(tfe.roomInfo.vnum)
      
  for dir, vnum in pairs(exits) do
    if (vnum == target) then 
      direction = dir
      break;
    end
  end
  
  return direction
  
end


tfe.advanceStepPosition = function (reverse)

  -- at destination
  if (not reverse and tfe.speedwalking.pathPosition &gt; #tfe.speedwalking.directions ) then
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;attempted to step beyond end of path\n')
    return nil
  end
  
  -- at start and reversed
  if (reverse and tfe.speedwalking.pathPosition == 1) then
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;attempted to reverse step below start of path\n')
    return nil
  end

  if(tfe.speedwalking) then
    if (not reverse) then
      tfe.speedwalking.pathPosition = tfe.speedwalking.pathPosition + 1
    else
      tfe.speedwalking.pathPosition = tfe.speedwalking.pathPosition - 1
    end
  end
end


tfe.rerouteSpeedwalk = function ()
  
  if (tfe.speedwalking) then 
    cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;rerouting speedwalk\n')
    if (tfe.speedwalking.roomChangeWatcher) then
      tfe.speedwalking.roomChangeWatcher()
      tfe.speedwalking.roomChangeWatcher = nil
    end
    tfe.configureWalkPath(tfe.speedwalking.destination, tfe.speedwalking.options)
  end
end


tfe.configureWalkPath = function (vnum, options)

  tfe.speedwalking = nil
  
  vnum = tostring(vnum)

  cecho('&lt;green&gt;pathing: &lt;white&gt;' .. tostring(tfe.roomInfo.vnum) .. ' to ' .. tostring(vnum))
	if (roomExists(tfe.roomInfo.vnum)) then
  	if (roomExists(tfe.roomInfo.vnum)) then
    
      getPath(tfe.roomInfo.vnum, vnum)
    
      tfe.speedwalking = {
        destination = vnum,
        path = speedWalkPath,
        directions = speedWalkDir,
        pathPosition = 1,
        options = options or {}
      }
    
      table.insert(tfe.speedwalking.path, 1, tostring(tfe.roomInfo.vnum))
      
     else
     
  		cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;unable to update path., destination not in map\n')
  	end
  	
	else
		cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;unable to update path., current room not in map\n')
	end

end



tfe.gotoRoom = function (vnum, options)
  
  if (type(options) == 'function') then
    local optCB = options
    options = {callback = optCB}
  elseif (type(options) == 'string') then
    local optString = options 
    options = {callback = function() send(optString) end}
  else
    if (options ~= nil) then
      cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;unknown options provided to tfe.gotoRoom\n')
    end
    options = {}
  end
  
  tfe.configureWalkPath(vnum, options)
  
  if (tfe.speedwalking) then
    tfe.speedWalkStep()
  end

end


-- to allow clicking the map
function doSpeedWalk()
 	tfe.gotoRoom(speedWalkPath[#speedWalkPath])
end


tfe.getPath = function(src, dest) 
  
  tfe.locations = tfe.locations or {}
  
  local srcRnum = tfe.locations[src] or src
  local destRnum = tfe.locations[dest] or dest
  
  if (type(srcRnum) == 'string' and srcRnum:match([[^%d+$]])) then
    srcRnum = tonumber(srcRnum)
  end
  if (type(destRnum) == 'string' and destRnum:match([[^%d+$]])) then
    destRnum = tonumber(destRnum)
  end
  
  
  if not (type(srcRnum) == 'number' and roomExists(srcRnum)) then
    return { error = 'Invalid start location ' .. src .. '\n' }
  end
  
  if not (type(destRnum) == 'number' and roomExists(destRnum)) then
    return { error = 'Invalid end location ' .. dest .. '\n' }
  end
  
  
  
  if getPath(srcRnum, destRnum) then
  
    cecho('&lt;green&gt;TFE MAP:&lt;white&gt; pathing from ' .. getRoomName(srcRnum) .. ' to ' .. getRoomName(destRnum) .. '\n')
    
    local pathDirs = speedWalkDir
    
    local pathDirssToString = function(dirs)
    
      local currentDir = ''
      local currentCount = 0
    
      local speedString = ''
      
      local addCurrent = function()
        if (currentDir ~= '') then
          if (currentCount &gt; 1) then
            speedString = speedString .. tostring(currentCount)
          end
          speedString = speedString .. currentDir
        end    
      end
      
      for i = 1, #dirs do
        
        local dir = dirs[i]
        if (dir == 'up') then dir = 'u' end
        if (dir == 'down') then dir = 'd' end
        
        if dir ~= currentDir then
          addCurrent()
          currentDir = dir
          currentCount = 1   
        else
          currentCount = currentCount + 1   
        end
        
      end
      
      addCurrent()
      
      return speedString
      
    
    end
    
    return {
      from = getRoomName(srcRnum),
        to = getRoomName(destRnum),
      path = pathDirssToString(pathDirs),
    }
     
  else
    return { error = 'No known path from ' .. getRoomName(srcRnum) .. ' to ' .. getRoomName(destRnum) }
  end
  
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>tfe.room_info_update</name>
			<packageName></packageName>
			<script>tfe = tfe or {}

tfe.consts = tfe.consts or {}

tfe.consts.exitmap = {
    n = 'north',    e = 'east',
    w = 'west',     s = 'south',
    u = 'up',       d = 'down',
	  N = 'north',    E = 'east',
    W = 'west',     S = 'south',
    U = 'up',       D = 'down',
    ["in"] = 'in',  out = 'out',
}


tfe.consts.short = {}
for k,v in pairs(tfe.consts.exitmap) do
    tfe.consts.short[v] = k
end

-- for some reason the speed walker doesn't use shorts for up/down
tfe.consts.exitmap['up'] = 'up'
tfe.consts.exitmap['down'] = 'down'

tfe.consts.stubmap = {
    north = 1,      east = 4,
    west = 5,       south = 6,
    up = 9,         down = 10,          
    ["in"] = 11,    out = 12,
    [1] = "north",  [4] = "east",
    [5] = "west",   [6] = "south",
    [9] = "up",     [10] = "down",
    [11] = "in",    [12] = "out",
}

-- in case an in/out goes to the same zone send it/down 100 layers so it doesn't overlap with an existing exit
tfe.consts.coordmap = {
    [1] = {0,1,0},      [4] = {1,0,0},
    [5] = {-1,0,0},     [6] = {0,-1,0},
    [9] = {0,0,1},      [10] = {0,0,-1},
    [11] = {0,0,100},     [12] = {0,0,-100}
}

tfe.consts.reverse_dirs = {
    north = "south", south = "north",
		west = "east", east = "west",
		up = "down", down = "up",
    ["in"] = "out", out = "in",
}

tfe.resetRoom = function ()
  tfe.roomInfo = gmcp.Room.Info
  tfe.previousRoomInfo = tfe.roomInfo
  tfe.lastMoveDirection = ''
end


tfe.room_info_update = function()
  
  local roomChanged = false
  
  -- only proceed if there is actually room info
  if (gmcp.Room.Info.area_id and gmcp.Room.Info.vnum) then
    
    if (tfe.roomInfo) then
    	
			-- if we changed rooms update lat move direction and previous room
			if (tfe.roomInfo.vnum ~= gmcp.Room.Info.vnum) then
			
        roomChanged = true
      
        tfe.previousRoomInfo = tfe.roomInfo
        tfe.lastMoveDirection = ''
        
        if (tfe.previousRoomInfo.vnum and getRoomExits(tfe.previousRoomInfo.vnum)) then
          for exit, vnum in pairs(getRoomExits(tfe.previousRoomInfo.vnum)) do
            if (vnum == gmcp.Room.Info.vnum) then
              tfe.lastMoveDirection = exit
              break
            end
          end
        end
        
        if (tfe.lastMoveDirection == '') then
          for exit, vnum in pairs(tfe.roomInfo.exits) do
            if (vnum == tfe.roomInfo.vnum) then
              tfe.lastMoveDirection = tfe.consts.reverse_dirs[exit]
              break
            end
          end
        end
        
        -- if we are badly out of sync set the last room to this room
        -- if (tfe.lastMoveDirection == '') then
          -- tfe.previousRoomInfo = gmcp.Room.Info
          -- tfe.lastMoveDirection = ''
        -- end
        
			end -- end if this room is diff from the prev room info room

    else
    
      -- first room in this session, set some sane defaults for prev room / direction
      tfe.previousRoomInfo = gmcp.Room.Info
      tfe.lastMoveDirection = ''

    end -- end if has room info
    
    tfe.roomInfo = gmcp.Room.Info 
    
    local areaId = tfe.getAreaID(tfe.roomInfo)
    
    -- if existing room center map on it
    if (not roomExists(tfe.roomInfo.vnum)) then

      -- adding new room
      
      local x = 0; local y = 0; local z = 0;
      
      local foundAdjacent = false

      if (tfe.pendingExit ~= nil and not tfe.roomInfo.exits[tfe.pendingExit.direction]) then 
        -- display(tfe.roomInfo)
        cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; added special exit from the room ' .. tfe.pendingExit.direction .. '!\n')
        tfe.roomInfo.exits[tfe.pendingExit.direction] = tfe.pendingExit.vnum
      end


      -- look for an adjacent room
      for exit, vnum in pairs(tfe.roomInfo.exits) do
        
        if (roomExists(vnum)) then
        
      		x,y,z = tfe.getRoomCoordinatesByExit(vnum, tfe.consts.reverse_dirs[exit])
      		-- echo('\nlocation is: ' .. tostring(x) .. ', ' .. tostring(y) .. ', ' .. tostring(z) .. ')\n')
          foundAdjacent = true
          
          break;
        
        end
        
      end -- end looping over exits
      
      
      
      if (#getAreaRooms(areaId) &gt; 0 and not foundAdjacent) then
        cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt; no adjacent room known or other rooms exist in this map!\n')
        cecho('You can use the "map connect &lt;direction you just went : [n|e|s|w|u|d|in|out]&gt; &lt;command you used to get here&gt;" to connect this room\n\n')
        display(tfe.previousRoomInfo)
        return
      end

      -- echo('\nlocation is: (' .. tostring(x) .. ', ' .. tostring(y) .. ', ' .. tostring(z) .. ')\n')

      addRoom(tfe.roomInfo.vnum)
		  setRoomArea(tfe.roomInfo.vnum, areaId);
  	  setRoomName(tfe.roomInfo.vnum, tfe.roomInfo.name)
  	  setRoomCoordinates(tfe.roomInfo.vnum, x, y, z)

    end
    
    -- updating exiting room if we haven't been into it before
    -- we can tell because it won't have a name yet...
    if (tfe.roomInfo.name ~= getRoomName(tfe.roomInfo.vnum)) then
  	  setRoomName(tfe.roomInfo.vnum, tfe.roomInfo.name)
      -- clear the temp room env color (grey)
      setRoomWeight(tfe.roomInfo.vnum, 1)
    end
    
    -- fix any area id's that have been mutilated by previous mappers
    if (getRoomArea(tfe.roomInfo.vnum) ~= areaId) then
      setRoomArea(tfe.roomInfo.vnum, areaId);
    end
    
    
    -- check terrain in this room
    local terrain = tfe.environment[tfe.roomInfo.terrain]
    if (terrain and getRoomEnv(tfe.roomInfo.vnum) ~= terrain) then
      setRoomEnv(tfe.roomInfo.vnum, terrain)
    end
    

		-- update room exit stubs (may change w/secret doors etc)
    local existingExits = getRoomExits(tfe.roomInfo.vnum)
		
    for exit, exitInfo in pairs(tfe.roomInfo.exit_info) do
			if(not existingExits[exit] and tfe.consts.short[exit]) then
      	setExitStub(tfe.roomInfo.vnum, tfe.consts.short[exit], true)
        
        -- add in a temp room for any rooms we haven't visited yet
        if (not roomExists(exitInfo.vnum)) then
          addRoom(exitInfo.vnum)
          setRoomArea(exitInfo.vnum, tfe.getAreaID(exitInfo));
          setRoomEnv(exitInfo.vnum, 272)
          -- set high room weight so we won't auto walk through it unless absolutely necessary
          setRoomWeight(exitInfo.vnum, 100)
          
          local x,y,z = tfe.getRoomCoordinatesByExit(tfe.roomInfo.vnum, exit)
          -- echo('\nnew location is: ' .. tostring(x) .. ', ' .. tostring(y) .. ', ' .. tostring(z) .. ')\n')
          setRoomCoordinates(exitInfo.vnum, x, y, z)
        end
      
        -- cecho('\n&lt;green&gt;MAPPER: &lt;white&gt;joining ' .. tostring(tfe.roomInfo.vnum) ..' to room: ' .. tostring(vnum) .. ' - ' .. exit)
        setExit(tfe.roomInfo.vnum, exitInfo.vnum, tfe.consts.stubmap[exit])
        if (tfe.roomInfo.area == 'The Ways' and exitInfo.area ~= 'The Ways') then
          cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; not adding reverse connection to the ways\n')
        else
          setExit(exitInfo.vnum, tfe.roomInfo.vnum, tfe.consts.stubmap[tfe.consts.reverse_dirs[exit]])
        end
        
			end
    end -- end looping over exits
  
  	centerview(tfe.roomInfo.vnum)

    if (roomChanged == true) then
      tfe.roomInfo.scanned = false
      if (tfe.supressNextRoomChange) then
        tfe.supressNextRoomChange = nil
      else
        raiseEvent(tfe.events.ROOM_CHANGED, tfe.roomInfo)
      end
    end
 
  else
  
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt; gmcp room info missing area id or room number\n')
    display(gmcp.Room.Info)
    
  end
  
  
end

tfe.getRoomCoordinatesByExit = function (vnum, dir)

  local x,y,z = getRoomCoordinates(vnum);
	local dx, dy, dz = unpack(tfe.consts.coordmap[tfe.consts.stubmap[dir]])
  x = x + dx
  y = y + dy
  z = z + dz
  return x, y, z
  
end

tfe.getAreaID = function(roomInfo)
  
  if (not roomInfo.area or roomInfo.area == '') then
    display('fucked up room info', gmcp.Room.Info)
    roomInfo.area = '???'
  end

  local area =  roomInfo.area .. ' : ' .. tostring(roomInfo.area_id)

	local areas = getAreaTable()
  
  if (areas[area]) then
    return areas[area]
  else
    cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;created new area: ' .. area .. '\n')
    return addAreaName(area)
  end

end

tfe.deleteCurrentMapArea = function ()
  
  local areaId = tfe.getAreaID(tfe.roomInfo)
  deleteArea(areaId)
  echo('\nRESET CURRENT AREA\n')
  updateMap()

end


tfe.deleteMapAreaByName = function (area)
    
  local areas = getAreaTable()  
  
  if (areas[area]) then  
    deleteArea(areas[area])
    echo('\nRESET AREA - ' .. area .. '\n')
    updateMap()
  end

end

tfe.deleteOrphanedRooms = function()
  
  for idx, val in ipairs(getAreaRooms(-1)) do
    deleteRoom(val)
  end

end

tfe.displayCurrentAreaExits = function ()
  
  local areaId = tfe.getAreaID(tfe.roomInfo)

  display( getAreaExits(areaId, true) )
  

end</script>
			<eventHandlerList>
				<string>gmcp.Room.Info</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>last script (to trigger dependencies!)</name>
			<packageName></packageName>
			<script>raiseEvent('tfeMapperLoaded')</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>speedwalk locations</name>
			<packageName></packageName>
			<script>tfe.locations = tfe.locations or {}

local lookup = {
	hillies = 28018,
	pixies = 44904,
  denab = 28132,
  denabBank = 30389,
	kha = 27004,
	khaBank = 27042,
	med = 107,
	medBank = 144,
	pen = 37013,
	penBank = 37249,
	sos = 30752,
	voal = 20088,
	voalBank = 20027,
	cairn = 26568,
	knight = 21096,
	hollow = 91675,
	blade = 19370,
	wayward = 40585,
  whisper = 28134,
	chi = 25000,
	zaranders = 27500,
	barbs = 66071,
	denab = 28132,
	brith = 63534,
	tg = 17331,
	cycs = 44765,
	stonies = 19164,
	toys = 39008,
	vyans = 28146,
	root = 19376,
	yetis = 94611,
	ettercaps = 70104,
	cairnValley = 57258,
	temple = 21257,
	narak = 36070,
	halflings = 21076,
  midnight = 76594,
  corsair = 42511,
  titans = 36759,
  fire = 25559,
  midnight = 76594,
  amber = 95016,
  outback = 54593,
  khiren = 34579,
  crabtown = 48158,
  fgs = 92559,
  monestry = 28067,
  slens = 76542,
  tgOut = 35817,
  wrath = 33084,
  landslide = 37045,
  brigade = 76504,
  swami = 24048,
  durkang = 92504,
  sighere = 11513,
}

for name, vnum in pairs(lookup) do
  if (not tfe.locations[name]) then
    tfe.locations[name] = vnum
  end
end</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>example-murder-bot</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>generic bot things</name>
				<packageName></packageName>
				<script>njs50bot =  njs50bot or {}

njs50bot.verbose = true

njs50bot.log = function(msg)
  if (njs50bot.verbose) then
    cecho(msg)
  end
end

njs50bot.isFull = function()
  
  if (gmcp.Char.Vitals.maxmv == gmcp.Char.Vitals.mv and 
      gmcp.Char.Vitals.en == gmcp.Char.Vitals.maxen and 
      gmcp.Char.Vitals.hp == gmcp.Char.Vitals.maxhp) then
    return true; 
  end
  
  return false;
  
end


njs50bot.sleepUntilFull = function (cb)
  
  -- if char is full then invoke callback
  if (njs50bot.isFull()) then
   
    njs50bot.log('\n&lt;green&gt;njs50bot:&lt;white&gt; character has full moves/en/hp, invoking callback\n')
    
    send('stand')
    
    cb()
    
  else
  
    if (gmcp.Char.Status.position == 'standing') then
      send('sleep')
    end
  
    njs50bot.log('\n&lt;green&gt;njs50bot:&lt;white&gt; not full, waiting on gmcp update\n')
 
    -- not full, check again on next gmcp update
    njs50.onNextEvent('gmcp.Char.Vitals', function()
      njs50bot.log(' &lt;yellow&gt;&lt;- gmcp update\n')
      njs50bot.sleepUntilFull(cb)
    end)
    
  end

end


njs50bot.getFullAndGo = function(roomNumber, cb)
  njs50bot.sleepUntilFull(function() 
    tfe.gotoRoom(roomNumber, function()
      if (cb) then cb() end
    end)
  end)
end


-- kills everything in the room! - this will probably get you dead
-- probably you should filter the list of things to kill and only kill specific mobs

njs50bot.killAll = function(cb)
  
  njs50bot.log('\n&lt;green&gt;njs50bot:&lt;white&gt; going to kill everything in this room...\n')
  
  local scanFailedTrigger, killNextScanHandler
  
  -- when we recieve new scan results, this is what we want to do:
  killNextScanHandler = njs50.onNextEvent(njs50.scanner.events.SCAN_PROCESSED, function()
    
    njs50bot.log('\n&lt;green&gt;njs50bot:&lt;white&gt; scan success\n')
    
    -- scan succeded so kill the scan fail trigger
    killTrigger(scanFailedTrigger);
    
    -- if nothing is left in the room invoke the callback
    if (not njs50.scanner.exits['[Here]'] or #njs50.scanner.exits['[Here]'] == 0) then
      njs50bot.log('\n&lt;green&gt;njs50bot:&lt;white&gt; kill all succeded\n')
      if (cb) then cb() end
    else
      
      -- pick the first thing on scan
      -- this list might need to be filtered for friendlies. i.e pets, group members
      local victim = njs50.scanner.exits['[Here]'][1].killString
      
      -- define these variables here so they are available inside all the functions we are about to make
      local victimMissingTrigger, noActionTimer, somethingDiedTrigger
      
      local cleanupTempThings = function()
        if (victimMissingTrigger) then killTrigger(victimMissingTrigger) end
        if (somethingDiedTrigger) then killTrigger(somethingDiedTrigger) end
        if (noActionTimer) then killTimer(noActionTimer) end
      end
      
      victimMissingTrigger = tempRegexTrigger([[(The room doesn't contain any beings|Nothing found) matching "]] .. victim .. [["\.$]], function()
        njs50bot.log('\n&lt;green&gt;njs50bot:&lt;white&gt; kill victim missing - scanning again in 5\n')
        -- failed to find/kill victim
        cleanupTempThings()
        tempTimer(5, function() njs50.killAll(cb) end)
      end, 1)
      
      somethingDiedTrigger = tempRegexTrigger([[You receive \d+ experience points\.$]], function()
        njs50bot.log('\n&lt;green&gt;njs50bot:&lt;white&gt; kill victim dead\n')
        -- failed to find/kill victim
        cleanupTempThings()
        njs50bot.killAll(cb)
      end, 1)
      
      noActionTimer = tempTimer(20, function()
        -- 20 seconds passed without anything dying or being not found. try scanning again
        njs50bot.log('\n&lt;green&gt;njs50bot:&lt;white&gt; kill all timed out, trying again\n')
        cleanupTempThings()
        njs50bot.killAll(cb)
      end)
      
      send('kill ' .. victim)
    end
    
  end)
  
  
  scanFailedTrigger = tempRegexTrigger([[The current battle has you occupied\.$]], function()
    
    njs50bot.log('\n&lt;green&gt;njs50bot:&lt;white&gt; kill all scan failed due to combat, trying again in 5\n')
    
    -- failed to scan due to combat, kill the handler for processing scan results
    killNextScanHandler()
    
    -- try again in 5 seconds
    tempTimer(5, function()
      njs50.killAll(cb)
    end)
    
  end, 1)
  

  send('scan')

end

njs50bot.checkRepop = function (roomId, regex, callback) 

  local startRoomId = tfe.roomInfo.vnum
  
  local repopped = true
 
  local noRepopTrigger = tempRegexTrigger(regex, function () 
    repopped = false
  end, 1)

  -- go to the check room and back to the start 
  -- makesure timeout is long enough to do this.
  tfe.gotoRoom(roomId, function()
    tfe.gotoRoom(startRoomId, function()
    
      -- if trigger hasn't run then repop happened
      if (repopped) then
        killTrigger(noRepopTrigger)
        njs50bot.log('\n\n&lt;green&gt;-=[ repopped ]=-\n')
        callback()
      else
        -- no repop
        local delay = 12 + math.random (1,8)
        
        njs50bot.log('\n\n&lt;orange&gt;-=[ no repop, waiting ' .. tostring(delay) .. 's ]=-\n')
        
        tempTimer(delay, function () 
          njs50bot.checkRepop(roomId, regex, callback)
        end, 'repop check') 
             
      end
    
    end)
  end) 
  

  
end

-- runs a function at each step of a path, then the callback when complete
-- stepFn needs to call a callback when complete to invoke the next step

-- njs50bot.executePath({41750, 41751, 41756, 41758, 41753, 41752}, njs50.killAll, function() send('cheer') end)

njs50bot.executePath = function (path, stepFn, cb)
 -- 41750, 41751, 41756, 41758, 41753, 41752
  local currentStep = 0
  
  local stepper
  
  stepper = function()
    
    if (currentStep == #path) then
      
      cecho('\n&lt;green&gt;njs50bot:&lt;white&gt; reached end of path\n')
      if (cb) then cb() end
      
    else
    
      currentStep = currentStep + 1
      local destination = path[currentStep]
      cecho('\n&lt;green&gt;njs50bot:&lt;white&gt; going to ' .. tostring(destination) .. '\n')
      tfe.gotoRoom(destination, function()
        stepFn(stepper)
      end)
      
    end
    
  end
 
  stepper()
 
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>mansion.bot</name>
				<packageName></packageName>
				<script>
njs50bot.mansion = function ()
  
  
  -- gets full then goes to repop then invokes the callback
  local gotoRepop = function(cb) 
    njs50bot.getFullAndGo(40582, cb) 
  end
  
  
  --  gets full, goes to room 41758, murders whatever is in the room, then invokes the callback
  local firstRoom = function(cb)
    njs50bot.getFullAndGo(41758, function()
      njs50bot.killAll(function()
        njs50bot.log('\n\n&lt;green&gt;SAMPLEBOT:&lt;white&gt; the first room is now clear!\n\n')
        -- we might want more custom code in here!
        cb()
      end)
    end) 
  end
 
  -- murders all the things in a room, then sleeps until full hp/mv/en before invoking callback.
  local genericRoomMurderAll = function(cb)
     njs50bot.killAll(function()
      njs50bot.sleepUntilFull(cb)
    end)  
  end

  
  local runComplete = function()
    njs50bot.log('\n\n&lt;green&gt;SAMPLEBOT:&lt;white&gt; mansion bot completed!\n\n')
    -- we might start the run again here if this was a real bot, mabye after some delay / loot sorting etc.
  end
  
  
  njs50bot.log('\n\n&lt;green&gt;SAMPLEBOT:&lt;white&gt; commencing mansion bot!\n\n')
  
  gotoRepop(function()
    
    njs50bot.checkRepop('41750', [[^\S+ \w+ coins? lies?]], function()
      
      -- manual first room
      firstRoom(function()
        
        -- generic path then goes through a list of rooms murdering everything then getting full hp etc before continuing
        njs50bot.executePath({41750, 41751, 41756, 41758, 41753, 41752}, genericRoomMurderAll, function() 
        
          -- leave a copper coin on the floor for the repop check
           tfe.gotoRoom(41750, function()
            send('drop copper.coin')
            
            -- go back to repop and run the run complete function
            gotoRepop(runComplete)
          end) 
                
        end) -- end execute path
        
      end) -- end first room
      
    end) -- end repop check
    
  end) -- end goto repop
  
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
