<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="yes" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>filter broken prompts</name>
			<script>if (rex.find(matches[1], [[^&lt;]])) then
  -- echo(' &lt;- prompt\n')
  raiseEvent(njs50.scanner.events.PROMPT)
 end</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^(?:&lt;[^&gt;]+&gt;)?([^&lt;].*)$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>scanner</name>
				<script>-- failing on: &lt;799hp 1304e 190mv 190wm 97384212xp NE&gt;      [Here] : Mohoonay, a tall, well-built horse, Grehild

      -- [Here] : Grehild, Darius, Affenaut, Uduvrin, Alavela, a Medienne Knight,
               -- a knight's heavy charger
        -- east : a Medienne guard

       -- scan : nothing in the vicinity

-- You see nothing in the vicinity.
if (matches[1] == 'You see nothing in the vicinity.' or matches[2] == 'scan') then
	
		-- echo(' &lt;-- reset exits')
  	njs50.scanner.resetExits();
	-- cecho(' &lt;- &lt;green&gt;SCANNER: &lt;white&gt;clear\n')
	raiseEvent(njs50.scanner.events.SCAN_PROCESSED)
		
else 

  local direction = matches[2]:gsub('^%s+','')
  
  if (direction ~= '' or njs50.scanner.scan_in_progress) then
  
    if (matches[3] == 'darkness') then
      njs50.scanner.scannedLine(direction, 'darkness')
      cecho('\n&lt;orange&gt;SCANNER: &lt;white&gt;should create better light before continuing\n')    
    else			
  		
      -- sometimes scan is jammed in with other content. scan lines are always indented with spaces
      -- so matches[2] should either be a bunch of space or a direction
      if (matches[3] ~= '' and matches[2] ~= '') then
  		  njs50.scanner.scannedLine(direction, matches[3])
      else
        -- scanning done, no need to wait for prompt (in case there is other junk before it)
        njs50.scanner.endScan()        
      end
  	 	
    end 
  
  end
		
 end -- end (if you see nothing)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\s+(north|east|south|west|up|down|scan|\[Here\])\s+:\s+(.+?),?$</string>
					<string>^\s+((?:far|north|east|south|west|up|down) (?:north|east|south|west|up|down))\s+:\s+(.+?),?$</string>
					<string>You see nothing in the vicinity.</string>
					<string>^(\s*)(.*?),?$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>2</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>rescan if something died</name>
				<script>if (not combat.active) then
  if (group.leader == player.name) then
    murder.scan('rescan because something died (out of combat)')
  -- else
    -- cecho('&lt;green&gt;&lt;-- skipped scan due to not being leader\n')
  end
end

--       A fair gnomish lass is DEAD!!</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\s+(An?|The) (.*) is DEAD!!</string>
					<string>^(An?|The) (.*) blindly flees </string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>You can't do that while mounted.</name>
				<script>njs50.onNextEvent(tfe.events.ROOM_CHANGED, function ()
  send('mount')
end)
send('dismount')
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You can't do that while mounted.</string>
					<string>You can't do that while mounted!</string>
					<string>You cannot go there while mounted.</string>
					<string>^\w+ is too large to fit through the .* to the (north|east|south|west)\.</string>
					<string>^\w+ is too large to fit through the hole beneath the dune below you\.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>The x to the y is closed.</name>
				<script>disableTrigger('The x to the y is closed.')

local vic = njs50.dotCase(njs50.toMurderString(matches[2]))

-- convert north gate etc -&gt; gate
vic = rex.gsub(vic, '(north|east|south|west|down|up|above|below).', '') 

local dir = matches[3]

send('move beam &amp; pull lever &amp; turn crank &amp; pull cord &amp; trace rune')
send('unlock ' .. vic .. ' &amp; unlock ' .. dir)
send('open ' .. vic .. ' &amp; open ' .. dir)
send('knock ' .. vic .. ' &amp; knock ' .. dir)
send('pound ' .. vic .. ' &amp; pound ' .. dir)

tempTimer(2, function () send('scan') end, 'scan after attempting to open')

tempTimer(1, function ()
	enableTrigger('The x to the y is closed.')
end, 'reenable closed door trig')
-- 
-- if (tfe.speedwalking) then
	-- send(tfe.lastMoveDirection)
-- end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^The (.+) to the (.+) (is|are) closed.</string>
					<string>^Perhaps you should open the (double) (doors)</string>
					<string>^The (.*) (below|above) you (is|are) closed.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>no exit - use special exit</name>
				<script>-- disableTrigger('no exit - use special exit')

local exit = matches[2]

if (exit == 'below') then exit = 'down' end
if (exit == 'above') then exit = 'up' end

-- if an exit opens scan




-- 
local exits = getRoomExits(tfe.roomInfo.num)
local specialExits = getSpecialExits(tfe.roomInfo.num)

if (exits and specialExits) then

  local targetRoom = exits[exit]
  
  if (targetRoom and specialExits[targetRoom]) then
    for command, idx in pairs(specialExits[targetRoom]) do 
      send(command)
    end
  else
    njs50.tempTimedNextEvent(5, njs50.gmcp.events.ROOM_EXITS_UPDATE, function()
      send('scan')
    end)  
    tfe.openExit(exit)    
  end

else
  
  njs50.tempTimedNextEvent(5, njs50.gmcp.events.ROOM_EXITS_UPDATE, function()
    send('scan')
  end)  
  tfe.openExit(exit)
  
end
-- 
-- tempTimer(1, function ()
	-- enableTrigger('no exit - use special exit')
-- end, 'reenable closed door trig')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You see no exit to the (.*)\.</string>
					<string>^You see no exit (.*) you\.</string>
					<string>^The .+ to the (.+) (is|are) closed.</string>
					<string>^The .* (below|above) you (is|are) closed.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>tell me path x to y</name>
				<script>local vic = matches[2]
local src = matches[3]

local dest = matches[4]


local path = tfe.getPath(src, dest)

if (path.error) then
  
  cecho('\n\n&lt;red&gt;TFE MAP:&lt;white&gt; ' .. path.error .. '\n\n')
  send('tell ' .. vic .. ' ' .. path.error)

else

  send('tell ' .. vic .. ' to go from ' .. path.from .. ' to ' .. path.to .. ' do:')
  send('tell ' .. vic .. ' ' .. rex.gsub(table.concat(path.path, ' &amp; '), ' &amp; ', ' \\&amp; '))
  
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^([A-Za-z]+) .*tells you:\s*"path (.+) to (.+?)\??"$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>modify exits line</name>
				<script>if (gmcp and gmcp.Room and gmcp.Room.Info) then
  
  local offset
  if (matches[1] == "[Exits:") then
    offset = -1
  else
    offset = -3
  end
  
  moveCursor(0, getLineNumber() + offset)
  
  -- remove some whitespace to keep things centered
  if (offset == -3) then
    selectString("    ", 1)
    replace("")
  end
  
  moveCursor(rex.find(getCurrentLine(), [[\S]]) - 1, getLineNumber())
  fg("red")
  insertText('#' .. tostring(gmcp.Room.Info.num) .. ' ')
  moveCursorEnd()
  resetFormat()
  
  -- add zone changes
  
  if (matches[1] == "[Exits:") then
    local text = getCurrentLine()
    for exit, data in pairs(gmcp.Room.Info.exit_info) do
      if (data.area_id ~= gmcp.Room.Info.area_id) then
        text = text:gsub(exit, '&lt;yellow&gt;' .. exit .. '&lt;reset&gt; (' .. data.area .. ')')
      end
    end
    selectCurrentLine()
    creplace(text)  
    deselect()
  else
    local text = ''
    for exit, data in pairs(gmcp.Room.Info.exit_info) do
      if (data.area_id ~= gmcp.Room.Info.area_id) then
        text = text .. '&lt;yellow&gt;' .. exit .. '&lt;reset&gt; is ' .. data.area .. '. '
      end
    end
    
    if (text ~= '') then
      cecho('\n| ' .. text .. '\n')
    end
  
  end
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>[Exits:</string>
					<string>^\|      Exits:.*$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>tell me locations</name>
				<script>local vic = matches[2]


local locStr = ''
for idx, loc in ipairs(table.keys(tfe.locations)) do
  
  if (idx % 25 == 1 and locStr ~= '') then
    send('tell ' .. vic .. ' I know about: ' .. locStr)
    locStr = ''
  end
  
  if (idx % 25 ~= 1) then locStr = locStr .. ', ' end
  
  locStr = locStr .. loc

end

if (locStr ~= '') then
  send('tell ' .. vic .. ' I know about: ' .. locStr)
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^([A-Za-z]+) .*tells you:\s*"locations"$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>pending movement</name>
				<script>-- You stomp west.
-- You leave east.
-- You ride Stinky east.
-- 
-- tfe.pendingMoveDirection = matches[2]

raiseEvent(tfe.events.ROOM_CHANGE_PENDING, matches[2])</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You (?:\w+|ride \w+) (north|east|south|west|up|down)\.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<Alias isActive="yes" isFolder="no">
			<name>map reset</name>
			<script>local commands = {
  
  reset = function(thing)
    if (thing == 'area') then
      tfe.deleteCurrentMapArea()
    end
  end,
  
  update = njs50.update_mapper,
  
}

if (commands[matches[2]]) then
  commands[matches[2]](matches[3])
else
  cecho('&lt;red&gt;TFE MAP: &lt;white&gt;unknown command - ' .. matches[2] .. '\n\n')
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^map (reset|update)\s?(.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>go</name>
			<script>local dest = matches[2]

tfe.locations = tfe.locations or {}

local rnum = tfe.locations[dest] or dest

if (type(rnum) == 'string' and rnum:match([[^%d+$]])) then
  rnum = tonumber(rnum)
end

if (type(rnum) == 'number' and roomExists(rnum)) then

	cecho('&lt;green&gt;TFE MAP:&lt;white&gt; going to ' .. getRoomName(rnum) .. '\n')
 
  local endCmd = matches[3]

	tfe.gotoRoom(rnum, { 
    callback = function () 
  		if (endCmd) then
  			expandAlias(endCmd)
  		end
  	end
  })
	
else
	cecho('\n&lt;red&gt;TFE MAP:&lt;white&gt; Invalid speed walk location: ' .. tostring(rnum) .. '\n')
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^go (\S+)\s?&amp;?\s?(.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>path</name>
			<script>local src = matches[2]
local dest = matches[3]

if not dest or dest == '' then
  dest = src
  src = gmcp.Room.Info.num
end

local path = tfe.getPath(src, dest)

if (path.error) then
  
  cecho('\n\n&lt;red&gt;TFE MAP:&lt;white&gt; ' .. path.error .. '\n\n')

else

  cecho('&lt;green&gt;TFE MAP:&lt;white&gt; to go from ' .. path.from .. ' to ' .. path.to .. ' is: ' .. table.concat(path.path, ' &amp; ') .. '\n')
  
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^path (\S+)\s?(\S+)?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>^(stop|pause|resume)$</name>
			<script>
local commands = {
  stop = tfe.speedwalkStop,
  pause = tfe.speedwalkPause,
  resume = tfe.speedwalkResume,
}

commands[matches[2]]()</script>
			<command></command>
			<packageName></packageName>
			<regex>^(stop|pause|resume)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>map - special exit</name>
			<script>local dir = matches[2]
local cmd = matches[3]

display(dir, cmd)

-- cancel an existing special exit if the move failed (maybe we were in the wrong room)
if (dir ~= 'cancel') then
  
  if (tfe.pendingSpecialExit) then
    tfe.pendingSpecialExit()
  end
  
  tfe.pendingExit = {
    direction = tfe.consts.reverse_dirs[tfe.consts.exitmap[dir]],
    vnum = tfe.roomInfo.num
  }
   
  
  tfe.pendingSpecialExit = njs50.onNextEvent(tfe.events.ROOM_CHANGED, function () 
  
    addSpecialExit(tfe.pendingExit.vnum, tfe.roomInfo.num, cmd)
    setExit(tfe.pendingExit.vnum, tfe.roomInfo.num, dir)
    setExitWeight(tfe.pendingExit.vnum, dir, 3)
      
    tfe.pendingSpecialExit = nil
    tfe.pendingExit = nil
    
    -- display(tfe.previousRoomInfo.num, 'to', tfe.roomInfo.num, cmd)
  
  end)
  
  cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; adding special exit!\n')
  cecho('&lt;green&gt;TFE MAP: &lt;white&gt; type "map exit cancel" to cancel if the command fails to change the room!\n')
  send(cmd)

else

  if (tfe.pendingSpecialExit) then
    tfe.pendingSpecialExit()
  end
  
  tfe.pendingExit = nil
  cecho('\n&lt;yellow&gt;TFE MAP: &lt;white&gt; cancelled adding special exit!\n')

end</script>
			<command></command>
			<packageName></packageName>
			<regex>^map exit (n|e|s|w|u|d|in|out|cancel) ?(.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>map - manual connect numbered to current</name>
			<script>-- not sure we need this anymore, only really useful for retroactively connecting things

local dir = matches[2]
local room2 = tonumber(matches[3])
local room1 = tfe.roomInfo.num
local cmd = matches[4] or ''

-- we may need to create the current room if it is orphaned in the zone from the prev room
if not roomExists(room1) then

  local areaId = tfe.getAreaID(tfe.roomInfo)
   
  local x,y,z = tfe.getRoomCoordinatesByExit(room2, tfe.consts.exitmap[dir])
  
  -- echo('\new location is: ' .. tostring(x) .. ', ' .. tostring(y) .. ', ' .. tostring(z) .. ')\n')
      
    addRoom(room1)
	  setRoomArea(tfe.roomInfo.num, areaId);
	  setRoomName(tfe.roomInfo.num, tfe.roomInfo.name)
	  setRoomCoordinates(tfe.roomInfo.num, x, y, z)  
    centerview(tfe.roomInfo.num)
    
    cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; added new room - ' .. dir .. ' from ' .. tfe.previousRoomInfo.name .. '\n')

end




if (roomExists(room1) and roomExists(room2)) then
  
  setExit(room2, room1, dir)
  
  if (cmd) then        
    addSpecialExit(room2, room1, cmd) 
    setExitWeight(room2, dir, 3) -- prioritize special exit
  end
  
  setExit(room2, room1, dir)
  centerview(room1)
    
  cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; connecting existing rooms!\n')
  
else

  cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt; room doesn\'t exist in map!: ' .. tostring(room2) .. '\n')

end
</script>
			<command></command>
			<packageName></packageName>
			<regex>^map add (n|e|s|w|u|d|in|out) (\d+) ?(.*)?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>map - connect current room with previous</name>
			<script>

local dir = matches[2]
local cmd = matches[3]

local room1 = tfe.roomInfo.num
local room2 = tfe.previousRoomInfo.num


  -- we may need to create the current room if it is orphaned in the zone from the prev room
  if not roomExists(room1) then
  
    local areaId = tfe.getAreaID(tfe.roomInfo)
     
    local x,y,z = tfe.getRoomCoordinatesByExit(room2, tfe.consts.exitmap[dir])
    
    -- echo('\new location is: ' .. tostring(x) .. ', ' .. tostring(y) .. ', ' .. tostring(z) .. ')\n')
        
      addRoom(tfe.roomInfo.num)
		  setRoomArea(tfe.roomInfo.num, areaId);
  	  setRoomName(tfe.roomInfo.num, tfe.roomInfo.name)
  	  setRoomCoordinates(tfe.roomInfo.num, x, y, z)  
      centerview(tfe.roomInfo.num)
      
      cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; added new room - ' .. dir .. ' from ' .. tfe.previousRoomInfo.name .. '\n')
  
  end




if (roomExists(room1) and roomExists(room2)) then
  
  setExit(room2, room1, dir)
  
  if (cmd) then        
    addSpecialExit(room2, room1, cmd) 
    setExitWeight(room2, dir, 3) -- prioritize special exit
  end
  
  setExit(room2, room1, dir)
  centerview(room1)
    
  cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; connecting existing rooms!\n')
  
else

  cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt; room doesn\'t exist in map!: ' .. tostring(room2) .. '\n')

end
</script>
			<command></command>
			<packageName></packageName>
			<regex>^map connect (n|e|s|w|u|d|in|out) ?(.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>lw</name>
			<script>
local areas = getAreaTable()  
  
local area1 = areas['The Ways : 51']
local area2 = areas['The Ways : 52']
  
-- display(area1, area2)


local exits = table.union(getAreaExits(area1, true), getAreaExits(area2, true))

-- display(exits)

cecho('\n')

for idx, exit in pairs(exits) do

  
  if (not exit.up) then
    
    local txt = ''
    
    for exitDir, rnum in pairs(exit) do
      txt = txt .. ' ' .. exitDir .. ': ' .. rex.gsub(getRoomAreaName(getRoomArea(rnum)), [[: \d+$]], '')
    end 
    
    txt = txt  ..'\n'
    
    if (matches[2] == '' or rex.find(txt, '(?i)' ..  matches[2])) then
      cecho('room #')
      cechoLink('&lt;green&gt;' .. tostring(idx) .. '&lt;reset&gt;', 'expandAlias("go ' .. tostring(idx) .. '")', '', true)
      if (matches[2] ~= '') then
        txt = rex.gsub(txt, '(?i)(' .. matches[2] .. ')', '&lt;yellow&gt;%1&lt;reset&gt;')
      end
      cecho(txt)
    end
    
  end
  
end



</script>
			<command></command>
			<packageName></packageName>
			<regex>^lw ?(.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>map - load</name>
			<script>-- "https://raw.githubusercontent.com/njs50/njs50-plev/master/njs50-map.dat"

local URL = matches[2]

uninstallPackage("generic_mapper")

if not URL:ends("dat") then

  cecho("&lt;red&gt;INSTALL: &lt;white&gt;map url doesn't appear to be valid, should be something like:\n") 
  cecho("&lt;white&gt;https://raw.githubusercontent.com/njs50/njs50-plev/master/njs50-map.dat\n")

else
  
  njs50.onNextEvent("sysDownloadDone", function (_, f)
    
    local loadOK = loadMap(f)
    
    if not loadOK then
     cecho("&lt;red&gt;INSTALL: &lt;white&gt;Couldn't load - was the mapper open? :(\n")
    else
      cecho("&lt;green&gt;INSTALL: &lt;white&gt;Loaded fine!\n")
    end
    os.remove(f)
  
  end)
  
  cecho("&lt;green&gt;MAP INSTALL: &lt;white&gt;downloading - " .. URL .. "\n")

  downloadFile(getMudletHomeDir().. "/njs50-map.dat", URL)
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^map load (.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>map - set drink target</name>
			<script>if (matches[2] and matches[2] ~= '') then
  cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; adding drink target in this room: ' .. matches[2] ..'\n')
  setRoomUserData(gmcp.Room.Info.num, 'drink-target', matches[2])
else
  cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; removing drink target in this room\n')
  clearRoomUserDataItem(gmcp.Room.Info.num, 'drink-target')
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^map drink ?(.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>map - set open command</name>
			<script>local dir = tfe.consts.exitmap[matches[2]]

if (matches[3] and matches[3] ~= '') then
  cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; added new command to open exit ' .. dir .. ' : ' .. matches[3] .. '\n')
  setRoomUserData(gmcp.Room.Info.num, 'open-' .. dir, matches[3])
else
  cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; removing command to open exit ' .. dir ..'\n')
  clearRoomUserDataItem(gmcp.Room.Info.num, 'open-' .. dir)
end

</script>
			<command></command>
			<packageName></packageName>
			<regex>^map open (n|e|s|w|u|d) ?(.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>fix special exits (replace with open commands)</name>
			<script>-- iterate over all rooms in code
for id,name in pairs(getRooms()) do
  local exits = getSpecialExits(id)
  
  if #table.keys(exits) &gt; 0 then
    -- display(exits)
    
    for rnum, cmds in pairs(exits) do
      -- display(rnum, cmds)
      for idx, cmd in pairs(table.keys(cmds)) do
        local newCmd, delay, queue, exit = rex.match(cmd, [[^(.+?)( &amp; wait \d+)?\s+&amp;\s+(\| ?|queue )?(north|east|south|west|up|down|n|e|s|w|u|d)\s*$]])
        if newCmd then
          -- display(rnum, cmd)
          -- display('command:', result,x,y,z)
          if tfe.consts.exitmap[exit] then exit = tfe.consts.exitmap[exit] end
          -- 
          display('removing old command in room #' .. tostring(id) .. ': ', cmd, 'adding new open metadata for ' .. exit .. ':', newCmd)
          -- 
          removeSpecialExit(id, cmd)
          setRoomUserData(id, 'open-' .. exit, newCmd)
          -- 
          
        end
      end
    end
    
  end
  
  
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^map fix special exits$</regex>
		</Alias>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>configuration</name>
			<packageName></packageName>
			<script>njs50 = njs50 or {}

njs50.config = {
  rewrite_scan = false, -- make scan results clickable (move or attack)
}






njs50.update_mapper = function ()

  local URL = "https://raw.githubusercontent.com/njs50/tfe-mapper/master/tfe-mapper.xml"
  
  njs50.onNextEvent("sysDownloadDone", function (_, f)
    if not f:find("tfe-mapper", 1, true) then 
      return 
    end
    uninstallPackage("tfe-mapper")
    installPackage(f)
    os.remove(f)
    cecho("&lt;lime_green&gt;Package installed!\n") 
  end)
  
  downloadFile(getMudletHomeDir()..(URL:ends("xml") and "/tfe-mapper.xml" or "/tfe-mapper.zip"), URL)

end

njs50.install_color_theme = function ()



end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>njs50 common</name>
			<packageName></packageName>
			<script>njs50 = njs50 or {}

njs50.tempTimedNextEvent = function(timeout, evt, callback, failCallback)
  local eventWatcher, timer
  
  eventWatcher = njs50.onNextEvent(evt, function(evt, args)
  		-- cecho('\n&lt;green&gt;EVENT: time limited next event happened: ' .. evt .. '\n')  
    killTimer(timer)
  		callback(evt, args)
  end)
  
  timer = tempTimer(timeout, function()
    -- cecho('\n&lt;orange&gt;EVENT: event didn\'t occur in time: ' .. evt .. '\n')
    eventWatcher()
    if (failCallback) then
      failCallback(evt, args)
    end
  end, 'event: ' .. evt .. ' (' .. tostring(timeout) .. 's)')
  
  -- destoy this temp timed event watcher
  return function()
    killTimer(timer)
    eventWatcher()
  end
  
end


njs50.tempTimedNextEventAnyway = function(timeout, evt, callback)
  return njs50.tempTimedNextEvent(timeout, evt, callback, callback)
end

njs50.onNextEvent = function (evt, callback)

	if not evt then
		cecho('\n\n&lt;red&gt;Next Event: &lt;white&gt;no event defined!!!\n\n')
		error()
	end


	local handlerId = nil
	local cb2 = callback

	local cb = function (evt, args)
		killAnonymousEventHandler(handlerId)
		cb2(evt, args)
	end

	handlerId = registerAnonymousEventHandler(evt, cb, true)

	-- cecho('\n&lt;green&gt;registering self destruct event: ' .. evt .. ' : ' .. tostring(handlerId) .. '\n')

	return function ()
		-- cecho('\n&lt;orange&gt;destructing handler: ' .. evt .. ' : ' .. tostring(handlerId) .. '\n')
		killAnonymousEventHandler(handlerId)
	end

end

njs50.tablelength = function(T)
  local count = 0
  for _ in pairs(T) do count = count + 1 end
  return count
end

njs50.timedTempTrigger = function (timeout, maxTriggerCount, pattern, callback, failcallback)

	local ofcb = failcallback
	local ocb = callback
  
  local fcb
  local cb
  local tempTimerId
  local triggerId
  maxTriggerCount = maxTriggerCount or 1
  
  local count = 0

	cb = function ()
		fcb = nil;
    ofcb = nil;
    count = count + 1
    if (count &gt;= maxTriggerCount) then
      killTrigger(triggerId)
    end
    -- echo('\n -- killing temp timed trigger timer\n')
    killTimer(tempTimerId)
		if (ocb) then
			ocb()
		end
	end
  
  fcb = function()
    cb = nil;
    ocb = nil;
    killTrigger(triggerId)
    if (ofcb) then
      ofcb()
    end
  end

	triggerId = tempRegexTrigger(pattern, cb, maxTriggerCount)

	tempTimerId = tempTimer(timeout, function ()
		-- echo('\n -- killing temp timed trigger\n')
	   fcb()
	end, 'timed temp trigger')

	return {triggerId = triggerId, timerId = tempTimerId}

end

njs50.killTimedTempTrigger = function (oTT)
  killTimer(oTT.timerId)
  killTrigger(oTT.triggerId)
end


timedTempTrigger = njs50.timedTempTrigger
killTimedTempTrigger = njs50.killTimedTempTrigger

tempTimedNextEvent = njs50.tempTimedNextEvent</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>formatters</name>
			<packageName></packageName>
			<script>common = common or {}

-- can add items to override from shortening if they mess up gear swapping
common.itemShortenOverride = common.itemShortenOverride or {}
common.itemShortenOverride['darkgem'] = 'darkgem'
common.itemShortenOverride['darklight'] = 'darklight'
common.itemShortenOverride['shadowbox'] = 'shadowbox'

-- bung keywords on item
common.itemShortenOverride['orange headband'] = 'orange.strip'
common.itemShortenOverride['emerald bracelet'] = 'emerald.bracelet'
common.itemShortenOverride['orange.headband'] = 'orange.strip'
common.itemShortenOverride['emerald.bracelet'] = 'emerald.bracelet'


common.consoleMessage = function(console, message, statusColor, excludeAll)

  local color = 'green'

  if (statusColor) then
    color = statusColor
  end

  common.chatConsole:cecho(console, '&lt;' .. color .. '&gt;' .. getTime(true, "hh:mm:ss") .. ': &lt;white&gt;' .. message .. "\n", excludeAll)
end


common.escape = function (str)
  str = rex.gsub(str, [[\\]], '\\\\')
  return str
end


common.formatElapsedTime = function (time)

	local ts = '';

	if (not time) then
		return '0 seconds'
	end

	local hrs = 0
	local mins = 0
	local secs = 0

	if (time &gt;= 3600) then
		hrs = math.floor(time / 3600)
		time = time - (hrs * 3600)
		ts = ts .. tostring(hrs) .. ' hrs, '
	end


	if (time &gt;= 60 or hrs &gt; 0) then
		mins = math.floor(time / 60)
		time = time - (mins * 60)
		ts = ts .. tostring(mins) .. ' mins, '
	end

	secs = math.floor(time)
	time = time - secs
	ts = ts .. tostring(secs) .. ' seconds'


	return ts

end

common.getNumber = function (text)

	local wordToNumberData = {
  	a = 1,
  	an = 1,
  	the = 1,
		one = 1,
		two = 2,
		three = 3,
		four = 4,
		five = 5,
		six = 6,
		seven = 7,
		eight = 8,
		nine = 9,
		ten = 10,
		eleven = 11,
		twelve = 12,
		thrirteen = 13,
		fourteen = 14,
	}

	local numTxt = rex.match(text, [[^\S+]])

	if (numTxt) then
		return wordToNumberData[string.lower(numTxt)] or 1
	else
		-- either it's more than 14 or a proper noun. i.e Stinky (your mount
		return 1
	end

end

common.cleanGmcpTarget = function(string)
  return common.dotCase(common.toMurderString(rex.gsub(rex.gsub(string, [[^\d+\.]], ''), [[\.]], ' ')))
end

common.dotCase = function(string)

	if (not string or string == '') then
		return ''
	end
	return rex.gsub(string, [[(?i)\b(the|or|an|a|of|with|and|A|An|The) ]], ''):gsub(' ', '.')
end


common.itemSanitize = function(string)

  if (not string or string == '') then
    return ''
  end



  string = rex.gsub(string, [[(\+chaotic\+,? |\+lawful\+,? |\+evil\+,? |\+good\+,? |acid-dripping,? |enchanted,? |empty,? |frost-covered,? |flaming,? |labeled |\s\+\d)]], '')

  if (string ~= 'frost-covered ring') then
    string = rex.gsub(string, [[frost-covered ]], '')
  end

  return string

end


common.itemShorten = function(item)

  -- replace "a large chopper 'big daddy'" with "a large chopper big"
  -- mud can't match big.dad. bah
  item = rex.gsub(item, [['([^']+)\s[^']+']], '%1')

  item = common.dotCase(common.itemSanitize(item))
  
  -- display(common.itemShortenOverride, item)
  
  if (common.itemShortenOverride[item]) then
    return common.itemShortenOverride[item]
  else
  
    return rex.gsub(	rex.gsub(item,"'(.*)'",'%1'),
      	'([^.][^.][^.][^.]?)[^.]+',
      	'%1'
    )
  end

end

common.commaCase = function (str)
    local extra = #str%3
    if string.sub(str,1,1) == "-" then
        if extra == 0 then
            extra = 3
        else
            extra = extra + 1
        end
    end
    local result = ""
    if extra &gt; 0 then
        result = string.sub(str,1,extra)
        str = string.sub(str,extra+1)
    end
    for w in string.gmatch(str,"%d%d%d") do
        result = result .. "," .. w
    end
    return result:gsub([[^,?]],'')
end


common.toMurderString = function (victim)

	-- remove any articles etc
	victim = rex.gsub(victim, [[(?i)\b(a|an|the|\+chaotic\+|\+lawful\+|\+evil\+|\+good\+|good|evil|The|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen)\s]], '')

	-- turn elves back into elf, dwarves etc
	victim = rex.gsub(victim, [[ves$]], 'f')

	-- turn women back to womans, guardsmen to guardsman
	victim = rex.gsub(victim, [[(\w+)men\b]], '%1man')
	-- drop i from end (plurals like homonculi
  
  local ignoreTerminalI = {
    yeti = true,
    targi = true,
    ['mammoth yeti'] = true,
  }
  
  local specialCases = {
    mice = 'mouse',
    ["ash-spirits"] = 'ash spirits',
  }

  if (specialCases[victim]) then
    victim = specialCases[victim]
  end

  if (not ignoreTerminalI[victim]) then
	 victim = rex.gsub(victim, [[i( |$)]], '%1')
  end

	 -- turn mercenaries back into mercanary
	victim = rex.gsub(victim, [[ies$]], 'y')

	-- dump any s's or es's on the end of a plural
	-- west : two greater cyclopses, vs a greater cyclops
	-- drudges should go to drudge tho...
	if (rex.find(victim, [[ses( |$)]])) then
		victim = rex.gsub(victim, [[ses( |$)]], 's%1')
	elseif (rex.find(victim, [[es( |$)]])) then
    -- cockroaches -&gt; cockroach
		victim = rex.gsub(victim, [[es( |$)]], '%1')
	else
		victim = rex.gsub(victim, [[('?s'?)( |$)]], '%2')
	end

	-- dump any random commas
	victim = rex.gsub(victim, [[,]], '')

	-- kill any parts less than 3 charaters

	victim = rex.gsub(victim, [[(^|\.|\s)\S\S?(\s|\.|$)]], '%1%2')

	-- kill any extra whitepsace or multiple .'s
	victim = rex.gsub(victim, [[(\s\s+|\.\.+)]], ' ')
	victim = string.trim(victim)

	-- kill any . at start or end.
	victim = rex.gsub(victim, [[^\.]], '')
	victim = rex.gsub(victim, [[\.$]], '')

	return victim

end

common.tableToString = function (table)
  
  local list = ''
  
  for idx, val in ipairs(table) do
  
    if type(val) == 'number' then val = tostring(val) end
    
    list = list .. val .. ', '
  
  end
  
  list = list:gsub(', $', '')
  
  return list
  
end

common.tableIndexesToString = function(t)

  local list = ''
  for idx, val in pairs(table.keys(t)) do
    if (idx ~= 1) then
      list = list .. ', '
    end
    if type(val) == 'number' then val = tostring(val) end
    list = list .. val
  end
  return list
end

common.getAreaName = function(roomId)
  local areaId = getRoomArea(roomId)
  local areaName = getRoomAreaName(areaId)
  
  return rex.gsub(areaName, [[\s+:\s+\d+$]], '')
  
end


-- copy these to njs50 scope for weird historical reasons
njs50.formatElapsedTime = common.formatElapsedTime
njs50.getNumber = common.getNumber
njs50.cleanGmcpTarget = common.cleanGmcpTarget
njs50.dotCase = common.dotCase
njs50.itemSanitize = common.itemSanitize
njs50.commaCase = common.commaCase
njs50.toMurderString = common.toMurderString
njs50.itemShorten = common.itemShorten
njs50.tableToString = common.tableToString
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>scanner</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- `echo      [Here] : a mountain bear, two mountain bear cubs, Bede, Ghosty, Brazden,
-- `echo              Ghosty

njs50.scanner = njs50.scanner or {}

njs50.scanner.events = {		
	SCAN_PROCESSED = 'SCANNER:rooms_scanned',
  PROMPT = 'SCANNER:prompt seen',
}

njs50.scanner.resetExits = function ()
	njs50.scanner.exits = {}
end


njs50.scanner.resetScanner = function ()
	njs50.scanner.scan_in_progress = false
  njs50.scanner.currentDirection = nil
	if (njs50.scanner.cancel_scan_in_progress) then
		njs50.scanner.cancel_scan_in_progress()
		njs50.scanner.cancel_scan_in_progress = nil
	end
	njs50.scanner.resetExits()
end

njs50.scanner.endScan = function()
  if (njs50.scanner.cancel_scan_in_progress) then
    njs50.scanner.cancel_scan_in_progress()
    njs50.scanner.cancel_scan_in_progress = nil
  end
  njs50.scanner.currentDirection = nil
  njs50.scanner.scan_in_progress = false

  -- cecho(' &lt;- &lt;green&gt;SCANNER: &lt;white&gt;scan ended\n')	
  raiseEvent(njs50.scanner.events.SCAN_PROCESSED, njs50.scanner.exits)

end

njs50.scanner.scannedLine = function (direction, mobs)  		
	
	if (not njs50.scanner.scan_in_progress) then
    -- cecho('\n&lt;green&gt;SCANNER: &lt;white&gt;scan started\n')
		njs50.scanner.resetExits();			
		njs50.scanner.scan_in_progress = true
    -- in case for some reason there isn't a blank line after the scan
    -- stop scanning ont the next prompt
		njs50.scanner.cancel_scan_in_progress = njs50.onNextEvent(njs50.scanner.events.PROMPT, njs50.scanner.endScan)
	end
  
	
  if (direction ~= "") then
    njs50.scanner.processingExit = direction
    
    -- sometimes two scans come in back to back with no gap. gotta reset direction whenever it is present
    -- i.e :
    -- south: yeti
    -- south: yeti
    -- should not = 2 yetis south
    njs50.scanner.exits[direction] = {}
    
    if (direction ~= '[Here]') then
      if njs50.config.rewrite_scan then
        selectString(direction,1)
        setUnderline(true)
        setLink([[send("]]..direction..[[")]], 'move ' .. direction)
        resetFormat()
      end
    end
    
  else
     direction = njs50.scanner.processingExit
  end
  
  njs50.scanner.exits[direction] = njs50.scanner.exits[direction] or {}
  
  -- convert strings to individual mobs
  -- nb: commas make this difficult as they might be in a mob name and not a seperator
  -- i.e. 
  
  
  local nubs = {}
  for s, c, r in rex.split(mobs, [[, (?=a |an |the |[A-Z]|two |three |four |five |six |seven |eight |nine |ten |eleven |twelve | thirteen |fourteen |fifteen )]]) do
    table.insert(nubs, s)
  end
  
  -- display(nubs)
  
  -- convert mobs to attack strings with counts
  for idx, mobString in pairs(nubs) do
    
    local mobRecord
    local ks = njs50.dotCase(njs50.toMurderString(mobString))
    local count = njs50.getNumber(mobString)
    
    -- check to see if there is already a mob with this name
    -- i.e east: a Medienne Knight, a Medienne Knight
    for idx, record in pairs(njs50.scanner.exits[direction]) do
      if (record.killString == ks) then
        mobRecord = record
        break;
      end
    end
    
    if (mobRecord == nil) then 
      mobRecord = { 
        raw = mobString, 
        killString = ks, 
        count = count 
      }
      table.insert(njs50.scanner.exits[direction], mobRecord)
    else
      mobRecord.count = mobRecord.count + count
    end
      
    if njs50.config.rewrite_scan then  
      selectString(mobRecord.raw,1)
      setUnderline(true)
      setLink([[send("]].. direction ..[[ &amp; k ]] .. mobRecord.killString .. [[")]], direction .. ' &amp; k ' .. mobRecord.killString)
      -- replace('xxxx')
      resetFormat()
    end
    
  end
	
end


njs50.findPlayer = function(name, cb)
  common.onNextEvent(njs50.scanner.events.SCAN_PROCESSED, function()
    for exit, contents in pairs(njs50.scanner.exits) do
      for idx, unit in pairs(contents) do
        if unit.raw == name then
          return cb(exit)
        end
      end
    end
    cb()
  end)
  murder.scan('looking for lost player')
end

murder = murder or {}
murder.scan = function(reason)

  if (reason) then
    cecho('\n&lt;green&gt;SCANNER:&lt;white&gt; scan because: ' .. reason .. '\n')
  end

  if (not  murder.scanPending) then
    
    murder.scanPending = true
    
    local scanTimer = tempTimer(10, function()
      murder.scanPending = nil
      cecho('\n&lt;orange&gt;SCANNER:&lt;white&gt; no scan within 10 seconds, trying again\n')
      murder.scan()
    end, 'pending scan')
    
    common.onNextEvent(njs50.scanner.events.SCAN_PROCESSED, function()
      murder.scanPending = nil
      killTimer(scanTimer)
    end)
    
    send('queue scan')
    
    
  else
  
    cecho('\n&lt;yellow&gt;SCANNER:&lt;white&gt; skipped scan due to pending scan...\n')
    
  end
  

end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>tfe mapper</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
mudlet = mudlet or {};
mudlet.mapper_script = true



tfe = tfe or {}

tfe.events = {
  ROOM_CHANGED = 'tfe mapper: room found',
  ROOM_CHANGE_PENDING = 'tfe mapper: move pending',
  WALK_COMPLETE = 'tfe mapper: speedwalk complete',
}


tfe.druidWayAreas = {
  ['The Ways : 51'] = true,
  ['The Ways : 52'] = true,
}
  


-- bleh 1-16 and 257-272 are reserved
tfe.environment = {
  
  Air = 41,
  ["Magical Cloud"] = 59,
  
  
  ["Dark Bamboo"] = 47, 
  ["Bamboo Forest"] = 42,
  Forest = 53,
  Jungle = 56,
  Rainforest = 25,
  Tree = 34, 
   
  Trail = 33, 
  ["Jungle Trail"] = 57,
  ["Forest Path"] = 54,
  
  Dirt = 49,

  ["Compost Zone"] = 46,
  
  Dump = 51,
  Pudding = 24,
  
  Path = 23,
  Road = 27,
  ["Town Street"] = 32,
    
  Tundra = 35, 
  Field = 52,
  
  Beach = 43,
  Desert = 48,
  ["White Sand"] = 39,
   
  Cave = 45,
 
  Lava = 58,
  
  Hills = 55,

  Bridge = 44,
  Mountain = 20,
  
  Underwater = 36,
  Water = 38,
  River = 26,
  ["Ocean Water"] = 22,

  Swamp = 31,
  
  Shallows = 29,
  ["Dry Riverbed"] = 50,
  
  Shipboard = 30,
  WoodenBoards = 40,
  
  Room = 28,
  
  Nondescript = 21,
  Void = 37,
  
  
  
  -- added by njs50 while wandering...
  ["Sandy Cavern"] = 100,
  
}


-- to see color optiosn
-- lua showColors(3)

tfe.environmentColor = {
  
  Air = 'deep_sky_blue',
  ["Magical Cloud"] = 'light_sky_blue',
  
  
  ["Dark Bamboo"] = 'dark_green', 
  
  ["Bamboo Forest"] = 'forest_green',
  Forest = 'forest_green',
  Jungle = 'forest_green',
  Rainforest = 'forest_green',
  Tree = 'lime_green',
   
  Path = 'khaki', 
  Trail = 'khaki', 
  ["Jungle Trail"] = 'khaki', 
  ["Forest Path"] = 'khaki', 
  
  Dirt = 'saddle_brown', 

  ["Compost Zone"] = 'saddle_brown',
  
  Dump ='saddle_brown',
  Pudding = 'saddle_brown',
  
  
  
  Road = 'dark_khaki',
  ["Town Street"] = 'dark_khaki',
    
  Tundra = 'wheat', 
  Field = 'wheat', 
  
  Beach = 'navajo_white',
  Desert = 'navajo_white',
  ["White Sand"] = 'navajo_white',
   
  Cave = 'dark_slate_gray',
 
  Lava = 'orange_red',
  
  Hills = 'dark_olive_green',

  Bridge = 'dark_olive_green',
  Mountain = 'dark_olive_green',
  
  Underwater = 'navy_blue',
  
  Water = 'dodger_blue',
  River = 'dodger_blue',
  ["Ocean Water"] = 'dodger_blue',

  Swamp = 'light_sky_blue',
  
  Shallows = 'light_sky_blue',
  
  ["Dry Riverbed"] = 'light_steel_blue',
  
  Shipboard = 'dark_khaki',
  WoodenBoards = 'dark_khaki',
  
  Room = 'beige',
  
  Nondescript = 'beige',
  
  Void = 'dark_slate_grey',

  -- added by njs50 (missing from terrain data)
  ["Sandy Cavern"] = 'navajo_white',
  
}

for terrain, color in pairs(tfe.environmentColor) do
  local r, g, b = unpack(color_table[color])
  setCustomEnvColor(tfe.environment[terrain], r, g, b, 255)
end


local shortSpeedWalkTimerId

tfe.startShortSpeedWalkTimer = function ()

	-- clear any existing timer
	tfe.clearShortSpeedWalkTimer()


	-- give us 5 seconds to move...
	shortSpeedWalkTimerId = tempTimer(5, function ()
		shortSpeedWalkTimerId = nil
		cecho('\n&lt;yellow&gt;TFE MAP: &lt;white&gt;5 seconds without room change!!! - updating path...\n')
    send('queue scan')
    tempTimer(2, function()
  		tfe.rerouteSpeedwalk()
      tfe.speedWalkStep()
    end)
	end)


end

tfe.clearShortSpeedWalkTimer = function()
	if (shortSpeedWalkTimerId) then
		killTimer(shortSpeedWalkTimerId)
	end
	shortSpeedWalkTimerId = nil
end

tfe.speedwalkPause = function ()
  if (tfe.speedwalking) then
    tfe.speedwalking.paused = true
    cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;speedwalking paused\n')
  else
   cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;not currently speedwalking\n')
  end
end

tfe.speedwalkResume = function ()
  if (tfe.speedwalking) then
    tfe.speedwalking.paused = nil
    cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;speedwalking resumed\n')
    tfe.speedWalkStep()
  else
     cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;not currently speedwalking\n')
  end
end

tfe.speedwalkStop = function ()
 
 if (tfe.speedwalking) then
    tfe.clearShortSpeedWalkTimer()
    -- clear any room change watcher if it exists
    if (tfe.speedwalking.roomChangeWatcher) then
      tfe.speedwalking.roomChangeWatcher()
      tfe.speedwalking.roomChangeWatcher = nil
    end
    
    tfe.speedwalking = nil
    cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;speedwalking stopped\n')
  else
     cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;not currently speedwalking\n')
  end
  
end


tfe.isExitClosed = function(direction)
  
  if(direction and direction ~= '') then
    
    local isSpecialExit = false
    local exits = getRoomExits(tfe.roomInfo.num)
    local specialExits = getSpecialExits(tfe.roomInfo.num)
    
    if (exits and specialExits) then
      local targetRoom = exits[direction]
      if (targetRoom and specialExits[targetRoom]) then
        isSpecialExit = true
      end
    end
    
    -- if it's not a special exit it must be linked in our map
    if (not isSpecialExit and tfe.consts.standardExits[direction] and not exits[direction]) then
      return false
    end
  
    -- if it's a standard exit it needs to have exit info
    -- if it's a special exit we will assume it is open/passable with that command
    if tfe.consts.standardExits[direction] and not isSpecialExit then
      local exitInfo = gmcp.Room.Info.exit_info[direction]
      if not exitInfo or table.contains(exitInfo.flags, 'closed') then
        return true
      end
    end   
     
  end
  
  return false
        
end

tfe.openExit = function(direction)

  local exitInfo = gmcp.Room.Info.exit_info[direction]
  local openCommand = getRoomUserData(gmcp.Room.Info.num, 'open-' .. direction)
  
  local isMounted = table.contains(gmcp.Char.Status.flags,"mounted")
  local isHidden = table.contains(gmcp.Char.Status.flags,"hiding")
  local isCamo = table.contains(gmcp.Char.Status.flags,"camouflaged")
  
  if isMounted then
    send('dismount')
  end
  
  if openCommand ~= '' then
    send(openCommand)
  else
    cecho('\n\n&lt;red&gt;TFE MAP: &lt;white&gt;unsure how to open the exit ' .. direction .. '\n')
    cecho('&lt;orange&gt;TFE MAP: &lt;white&gt;use "&lt;green&gt;map open ' .. direction:sub(1,1) .. ' &lt;cmd&gt;&lt;white&gt;" to set the command to open the exit\n')
    cecho('&lt;orange&gt;TFE MAP: &lt;white&gt;use "&lt;green&gt;map exit [n|e|s|w|u|d|in|out] &lt;cmd&gt;&lt;white&gt;" to add a special exit command \n' )
    cecho('&lt;yellow&gt;TFE MAP: &lt;white&gt;setting an open command with &lt;green&gt;map open&lt;white&gt; is best, but for exits like enter portal where no\n') 
    cecho('         &lt;white&gt;entrance appears you need to use a special exit\n' )
    if (exitInfo and table.contains(exitInfo.flags, 'locked')) then
    
      send('unlock ' .. direction)
    end
    
    send('open ' .. direction)
  end
  
  if isMounted then
    send('mount')
  end
  
  if isHidden then
    send('hide')
  end
  
  if isCamo then
    send('camo')
  end

end

        
tfe.speedWalkStep = function ()
  
  tfe.clearShortSpeedWalkTimer()
  -- clear any room change watcher if it exists
  if (tfe.speedwalking and tfe.speedwalking.roomChangeWatcher) then
    tfe.speedwalking.roomChangeWatcher()
    tfe.speedwalking.roomChangeWatcher = nil
  end

  if (tfe.speedwalking) then
    
    
    -- check we are not off course...
    local nextStep = tfe.getNextStep()

    if (nextStep == nil) then
            
      -- clearing current walk before callback in case cb creates new path      
  
      
      -- we made it to the end. call the callback if it exists
      cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;at destination\n')
      if (tfe.speedwalking.options and tfe.speedwalking.options.callback) then
        local cb = tfe.speedwalking.options.callback
        tfe.speedwalking = nil
        raiseEvent(tfe.events.WALK_COMPLETE)
        cb()
      else  
        tfe.speedwalking = nil
        raiseEvent(tfe.events.WALK_COMPLETE)
      end
      
      
    
    else
    
      -- we are where we should be. send a move etc
      
      if (not tfe.speedwalking.paused) then

        tfe.startShortSpeedWalkTimer()

        -- send command
        if(nextStep and nextStep ~= '') then
                    
          local exitClosed = tfe.isExitClosed(nextStep)
          
          -- instead of trying to exit we will try to open the exit
          if exitClosed then

            tfe.speedwalking.roomChangeWatcher = njs50.onNextEvent(njs50.gmcp.events.ROOM_EXITS_UPDATE, function() 
              -- step completed. do next step    
              tfe.speedWalkStep()
            end)
            
            tfe.openExit(nextStep)            
          
          else
           
            -- setup a single event watcher for a room change
            tfe.speedwalking.roomChangeWatcher = njs50.onNextEvent(tfe.events.ROOM_CHANGED, function() 
              -- step completed. do next step    
              tfe.speedWalkStep()
            end)
            send( nextStep )    
            tfe.advanceStepPosition()
                     
          end
                       
          
        else
          cecho('\n\n&lt;red&gt;TFE MAP: &lt;white&gt;unsure  how to progress (missing special exit?)\n')
        end
        
      else
        cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;speedwalking paused\n')
      end
    
    end
      
      
    
    
  else
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;unable to take step, not currently speedwalking\n')
  end

end

tfe.getNextStep = function (reverse)
  -- not currently going anywhere
  if (not tfe.speedwalking) then
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;no next step available, no path configured\n')
    return nil
  end
  

  -- check if we are lost and need to reroute...  
  if (tostring(tfe.roomInfo.num) ~= tfe.speedwalking.path[tfe.speedwalking.pathPosition]) then
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;2 expected to be in room ' .. tfe.speedwalking.path[tfe.speedwalking.pathPosition] .. ' but was in ' .. tostring(tfe.roomInfo.num) ..', recalculating path \n')
    
    local expectedArea = getRoomAreaName(getRoomArea(tfe.speedwalking.path[tfe.speedwalking.pathPosition]))
    -- if they expected to be in the ways send them back there
    
    if (gmcp.Char.Score.class == 'druid' and rex.match(expectedArea, [[^The Ways]]) and druid and druid.landwalk) then
      tfe.supressNextRoomChange = true
      cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;going to ways\n')
      druid.landwalk(function()
        tfe.supressNextRoomChange = nil
        tfe.rerouteSpeedwalk()
        send('queue scan')      
      end)
    else
      tfe.rerouteSpeedwalk()
      send('queue scan')
    end
    
    return ''
    
  end  
  
  -- at destination
  if (not reverse and tostring(tfe.roomInfo.num) == tfe.speedwalking.destination) then
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;no next step available, at destination\n')
    return nil
  end
  
  -- at start and reversed
  if (reverse and tfe.speedwalking.pathPosition == 1) then
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;no next step available, at start and walking backwards\n')
    return nil
  end
   
  if (not reverse) then

    return tfe.consts.exitmap[ tfe.speedwalking.directions[tfe.speedwalking.pathPosition] ] or tfe.speedwalking.directions[tfe.speedwalking.pathPosition]      
  
  else
  
    local specialExits = getSpecialExits(tfe.roomInfo.num)
    local targetRoom = tonumber(tfe.speedwalking.path[tfe.speedwalking.pathPosition - 1])
    
    local cmd = ''
    
    if (specialExits and specialExits[targetRoom]) then
      for command, idx in pairs(specialExits[targetRoom]) do 
        cmd = cmd .. command .. ' &amp; '
      end
      cmd = cmd:gsub([[ &amp; $]], '')
      
    else
      cmd = tfe.consts.reverse_dirs[ tfe.consts.exitmap[ tfe.speedwalking.directions[tfe.speedwalking.pathPosition - 1] ] ]
    end
    
    return cmd  
  
  end
  
end

tfe.getNextDirection = function (reverse)

  -- not currently walking anywhere
  if (not tfe.speedwalking) then
    return nil
  end
   
    -- check if we are lost and need to reroute...  
  if (tostring(tfe.roomInfo.num) ~= tfe.speedwalking.path[tfe.speedwalking.pathPosition]) then
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;expected to be in room ' .. tfe.speedwalking.path[tfe.speedwalking.pathPosition] .. ' but was in ' .. tostring(tfe.roomInfo.num) ..', recalculating path \n')
    tfe.rerouteSpeedwalk()
    send('queue scan')
    return nil
  end
   
  -- at destination
  if (not reverse and tostring(tfe.roomInfo.num) == tfe.speedwalking.destination) then
    return nil
  end
  
  -- at start and reversed
  if (reverse and tfe.speedwalking.pathPosition == 1) then
    return nil
  end

  
  local nextpos = tfe.speedwalking.pathPosition
    
  if (reverse) then
    nextpos = nextpos - 1
  else
    nextpos = nextpos + 1
  end
  
  local target = tonumber(tfe.speedwalking.path[nextpos])
  local exits = getRoomExits(tfe.roomInfo.num)
      
  for dir, vnum in pairs(exits) do
    if (vnum == target) then 
      direction = dir
      break;
    end
  end
  
  return direction
  
end


tfe.advanceStepPosition = function (reverse)

  -- at destination
  if (not reverse and tfe.speedwalking.pathPosition &gt; #tfe.speedwalking.directions ) then
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;attempted to step beyond end of path\n')
    return nil
  end
  
  -- at start and reversed
  if (reverse and tfe.speedwalking.pathPosition == 1) then
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;attempted to reverse step below start of path\n')
    return nil
  end

  if(tfe.speedwalking) then
    if (not reverse) then
      tfe.speedwalking.pathPosition = tfe.speedwalking.pathPosition + 1
    else
      tfe.speedwalking.pathPosition = tfe.speedwalking.pathPosition - 1
    end
  end
end


tfe.rerouteSpeedwalk = function ()
  
  if (tfe.speedwalking) then 
  
    cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;rerouting speedwalk\n')

      -- remove any destinations we have already passed
    
      local currentWptIdx = 1 
      for pv = 1, tfe.speedwalking.pathPosition do
        if (tfe.speedwalking.path[pv] == tfe.speedwalking.destination[currentWptIdx]) then
          currentWptIdx = currentWptIdx + 1
        end
      end
      
      local newDestinations = {}
      
      for ndIdx = currentWptIdx, #tfe.speedwalking.destination do
        table.insert(newDestinations, tfe.speedwalking.destination[ndIdx])
      end

    if (tfe.speedwalking.roomChangeWatcher) then
      tfe.speedwalking.roomChangeWatcher()
      tfe.speedwalking.roomChangeWatcher = nil
    end
    
    return tfe.configureWalkPath(newDestinations, tfe.speedwalking.options, false)
  
  end
  
  
end

tfe.getExpandedPath = function(currentWpt, waypoints) 
  
  if (roomExists(currentWpt)) then
  
    local path = {}
    local pathDirs = {}
    
    if (type(waypoints) ~= 'table') then
      waypoints = {waypoints}
    end
    
    for idx, waypoint in ipairs(waypoints) do 
    
      if getPath(currentWpt, waypoint) then
         table.insert(path, speedWalkPath)
         table.insert(pathDirs, speedWalkDir)
      else
        cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;No known path from ' .. 
          getRoomName(currentWpt) .. ' to ' .. (getRoomName(waypoint) or 'unknown room') .. '\n')
        return nil
      end
    
      currentWpt = waypoint
    end -- end waypoint loop
    
    speedWalkPath = table.n_flatten(path)
    speedWalkDir = table.n_flatten(pathDirs)
    
    return true
	
	else
		cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;unable to update path., starting room not in map\n')
    return nil
	end

end


tfe.configureWalkPath = function (vnum, options, takeStep)

  local currentRoom = gmcp.Room.Info.num

  tfe.speedwalking = nil
  
  local dstring = tostring(vnum)
  
  if (type(vnum) ~= 'table') then
    vnum = {vnum}
  end
  
  dstring = table.concat(vnum, ', ')

  cecho('&lt;green&gt;pathing: &lt;white&gt;' .. tostring(currentRoom) .. ' to ' .. dstring .. '\n') 


  if tfe.getExpandedPath(currentRoom, vnum) then
  
    tfe.speedwalking = {
      destination = vnum,
      path = speedWalkPath,
      directions = speedWalkDir,
      pathPosition = 1,
      options = options or {}
    }
  
    table.insert(tfe.speedwalking.path, 1, tostring(currentRoom))
    
    if (takeStep and tfe.speedwalking) then
      tfe.speedWalkStep()
    end
    
    return true
    
  else 
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;unreachable destination ' .. dstring .. '\n')
    

    -- landwalk if available and required
    local destArea = getRoomAreaName(getRoomArea(vnum[1]))
    
    -- if they are attempting to walk to the ways they will require intervention
    if (tfe.druidWayAreas[destArea] and gmcp.Room.Info.area ~= "The Ways") then
      
      -- if they have the njs50-druid package attempt to landwalk
      if (druid and druid.landwalk) then
      
        cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;attempting to use the druid ways\n')
        druid.landwalk(function()
          tfe.configureWalkPath(vnum, options, takeStep)
        end)
        return
      
      else
        cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;attempted to walk to the druid ways\n')
      end
    
      return
    end  
      
  
  end
        


  return false

end



tfe.gotoRoom = function (vnum, options)
  
  if (type(options) == 'function') then
    local optCB = options
    options = {callback = optCB}
  elseif (type(options) == 'string') then
    local optString = options 
    options = {callback = function() send(optString) end}
  elseif (type(options) ~= 'table') then
    if (options ~= nil) then
      cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;unknown options provided to tfe.gotoRoom\n')
      display(type(options), options)
    end
    options = {}
  end
  
  -- make sure vnum is a number
  vnum = tfe.locations[vnum] or vnum
  if (type(vnum) == 'string' and vnum:match([[^%d+$]])) then
    vnum = tonumber(vnum)
  end 
  
  tfe.configureWalkPath(vnum, options, true)

end


-- to allow clicking the map
function doSpeedWalk()
 	tfe.gotoRoom(speedWalkPath[#speedWalkPath])
end


tfe.getPath = function(src, dest) 
  
  tfe.locations = tfe.locations or {}
  
  local srcRnum = tfe.locations[src] or src
  local destRnum = tfe.locations[dest] or dest
  
  if (type(srcRnum) == 'string' and srcRnum:match([[^%d+$]])) then
    srcRnum = tonumber(srcRnum)
  end
  if (type(destRnum) == 'string' and destRnum:match([[^%d+$]])) then
    destRnum = tonumber(destRnum)
  end
  
  
  if not (type(srcRnum) == 'number' and roomExists(srcRnum)) then
    return { error = 'Invalid start location ' .. src .. '\n' }
  end
  
  if not (type(destRnum) == 'number' and roomExists(destRnum)) then
    return { error = 'Invalid end location ' .. dest .. '\n' }
  end
  
  
  
  if getPath(srcRnum, destRnum) then
  
    cecho('&lt;green&gt;TFE MAP:&lt;white&gt; pathing from ' .. getRoomName(srcRnum) .. ' to ' .. getRoomName(destRnum) .. '\n')
    
    local pathDirs = speedWalkDir
    
    local pathDirssToString = function(dirs)
    
      local currentDir = ''
      local currentCount = 0
    
      local speedString = ''
      
      local instructions = {}
      
      local addCurrent = function()
        if (currentDir ~= '') then
          if (currentCount &gt; 1) then
            speedString = speedString .. tostring(currentCount)
          end
          speedString = speedString .. currentDir
        end    
      end
      
      local finishCurrent = function()
        if (currentDir ~= '') then
          addCurrent()
          currentDir = ''
          currentCount = 0
        end
        if (speedString ~= '') then
          table.insert(instructions, '|speed ' .. speedString)
          speedString = ''
        end
      end
      
      for i = 1, #dirs do
        
        local dir = dirs[i]
        if (dir == 'up') then dir = 'u' end
        if (dir == 'down') then dir = 'd' end
        
        if not dir:match("^[neswud]$") then
          finishCurrent()
          table.insert(instructions, '|' .. rex.gsub(dir, ' &amp; ([^|])', ' &amp; |%1'))
        elseif dir ~= currentDir then
          addCurrent()
          currentDir = dir
          currentCount = 1   
        else
          currentCount = currentCount + 1   
        end
        
      end
      
      finishCurrent()
      
      return instructions
    
    end
    
    return {
      from = getRoomName(srcRnum),
        to = getRoomName(destRnum),
      path = pathDirssToString(pathDirs),
    }
     
  else
    return { error = 'No known path from ' .. getRoomName(srcRnum) .. ' to ' .. getRoomName(destRnum) }
  end
  
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>speedwalk locations</name>
			<packageName></packageName>
			<script>tfe.locations = tfe.locations or {}

local lookup = {
  hillies = 28018,
  pixies = 44904,
  denab = 28132,
  denabBank = 30389,
  kha = 27008,
  khaBank = 27042,
  med = 107,
  medBank = 144,
  khaWeap = 27031,
  khaArmor = 27036,
  pen = 37013,
  penBank = 37249,
  sos = 30752,
  sosBank = 30874,
  voal = 20088,
  voalBank = 20027,
  cairn = 26568,
  knight = 21096,
  hollow = 91675,
  blade = 19370,
  wayward = 40585,
  whisper = 28134,
  chi = 25000,
  zaranders = 27500,
  barbs = 66071,
  brith = 63534,
  brithBank = 63521,
  tg = 17331,
  cycs = 44765,
  stonies = 19164,
  toys = 39008,
  vyans = 28146,
  root = 19376,
  yetis = 94611,
  ettercaps = 70104,
  cairnValley = 57258,
  temple = 21257,
  narak = 36070,
  narakBank = 36094,
  halflings = 21076,
  midnight = 76594,
  corsair = 42511,
  titans = 36759,
  fire = 25559,
  midnight = 76594,
  amber = 95016,
  outback = 54593,
  khiren = 34579,
  crabtown = 48158,
  fgs = 92559,
  monastery = 28067,
  slens = 76542,
  tgOut = 35817,
  wrath = 33084,
  landslide = 37045,
  brigade = 76504,
  swami = 24048,
  durkang = 92504,
  sighere = 11513,
  wastes = 58020,
  fgs = 92559,
  direwolves = 33027,
  darkhaven = 30026,
  dh = 30026,
  darkhavenBank = 30011,
  dhBank = 30011,
  jungle = 5821,
  beach = 5874,
  cave = 5860,
  forest = 5850,
  bamboo = 5837,
  tundra = 5817,
  desert = 5855,
  hills = 5801,
  field = 5802,
  swamp = 5803,
  mountain = 5800,
  highMonk = 12500,
  mindflayer = 2551,
  minos = 92588,
  starwater = 19377,
  cathedral = 21009, 
  darkCitadel = 23074, 
  luerna = 31051,
  plantation = 16776,
  kobolds = 26574,
  rabbits = 38324,
  tombOfOrder = 57309,
  crone = 36011,
  isle = 36126,
  orl = 33501,
  orlBank = 33551,
}

for name, vnum in pairs(lookup) do
  if (not tfe.locations[name]) then
    tfe.locations[name] = vnum
  end
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>last script (to trigger dependencies!)</name>
			<packageName></packageName>
			<script>raiseEvent('tfeMapperLoaded')</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>searches</name>
			<packageName></packageName>
			<script>njs50 = njs50 or {}

njs50.roomSearches = {


  -- spooky isles part 1
  
  ['10607'] = {
    'search seaweed',
    'search seashell',
    'search shell',
  },
  
  ['10608'] = {
    'search tree',
    'search trunk',
  },
  
  ['10609'] = {
    'search rib'
  },
  
  ['10612'] = {
    'search tree'
  },
    
  ['10613'] = {
    'search fern'
  },  
      
  ['10616'] = {
    'pick plant &amp; pluck plant &amp; pick plant &amp; pluck plant'
  },
 
  ['10618'] = {
    'pick thorn &amp; pick thorn &amp; pick thorn &amp; pick thorn &amp; put all.thorn backpack'
  },
  
    
  ['10621'] = {
    'search puddle &amp; search puddle'
  },  
  
  ['10626'] = {
    'pick berry &amp; pick berry &amp; pick berry &amp; pick berry &amp; pick berry'
  },
   
  ['10628'] = {
    'search vine &amp; search vine'
  }, 
  


  ['10630'] = {
    'pick berry &amp; pick berry &amp; pick berry &amp; pick berry &amp; pick berry'
  },   
  
  ['10634'] = {
    'pick flower &amp; pick flower &amp; pick flower &amp; pick flower'
  }, 
    
  ['10635'] = {
    'search trunk &amp; search trunk',
    'harvest cassava &amp; harvest cassava &amp; harvest cassava',
  },
    
  
  ['10637'] = {
    'pick berry &amp; pick berry &amp; pick berry &amp; pick berry &amp; pick berry'
  },   
      
  ['10638'] = {
    'search root'
  },
   
      
  ['10643'] = {
    'search bush'
  },
     
  ['10646'] = {
    'search couch',
    'search tap'
  },  

  ['10647'] = {
    'search furniture',
    'search ash',
  },
   
  ['10648'] = {
    'search table',
    'search bench',
    'search cabinet',
  },
    
  
  ['10649'] = {
    'search shel',
    'search table',
    'search scon',
    'search ash',
    'search sill',
    'search window',
    'search bench',
  },
  
    
  ['10668'] = {
    'search sand &amp; search sand &amp; search jelly',
  },
  
  -- spooky isles part 2

  
  ['11104'] = {
    'search fungus',
    'get raff',
  },
    
  ['11105'] = {
    'pick flower &amp; pick flower &amp; pick flower &amp; pick flower',
    'pluck flower &amp; pluck flower &amp; pluck flower',
    'get bark &amp; get bark',
  },

  ['11109'] = {
    'search crevice'
  },  

  ['11110'] = {
    'search fern',
    'search moss',
  },
  
  ['11112'] = {
    'search fern'
  },
  
-- this one might hurt
-- ['11114'] = {
  -- 'cut tendril'
  -- -- 'cut tendril'
-- },

  ['11116'] = {
    'search vine',
    'pick flower &amp; pick flower &amp; pick flower &amp; pick flower'
  },

   
  ['11122'] = {
    'search book',
    'search cabinet',
    'search table',
  },    

   
  ['11123'] = {
    'search couch',
    'search bed',
    'search shelf',
    'search table',
  },    
  


}

njs50.search = function(vnum)
  
  vnum = vnum or gmcp.Room.Info.vnum
  
  vnum = tostring(vnum)
  
  local searches = njs50.roomSearches[vnum]
  
  if (searches) then
    for idx, cmd in ipairs(searches) do 
      send(cmd)
    end
  end

end</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>example-murder-bot</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>generic bot things</name>
				<packageName></packageName>
				<script>njs50bot =  njs50bot or {}

njs50bot.verbose = true

njs50bot.log = function(msg)
  if (njs50bot.verbose) then
    cecho(msg)
  end
end

njs50bot.isFull = function()
  
  if (gmcp.Char.Vitals.maxmv == gmcp.Char.Vitals.mv and 
      gmcp.Char.Vitals.en == gmcp.Char.Vitals.maxen and 
      gmcp.Char.Vitals.hp == gmcp.Char.Vitals.maxhp) then
    return true; 
  end
  
  return false;
  
end


njs50bot.sleepUntilFull = function (cb)
  
  -- if char is full then invoke callback
  if (njs50bot.isFull()) then
   
    njs50bot.log('\n&lt;green&gt;njs50bot:&lt;white&gt; character has full moves/en/hp, invoking callback\n')
    
    send('stand')
    
    cb()
    
  else
  
    if (gmcp.Char.Status.position == 'standing') then
      send('sleep')
    end
  
    njs50bot.log('\n&lt;green&gt;njs50bot:&lt;white&gt; not full, waiting on gmcp update\n')
 
    -- not full, check again on next gmcp update (or after 5 seconds)
  
    local retry = function()
      njs50bot.log(' &lt;yellow&gt;&lt;- gmcp update (or 5s timeout)\n')
      njs50bot.sleepUntilFull(cb)
    end
    njs50.tempTimedNextEvent(5, 'gmcp.Char.Vitals', retry, retry)
    
  end

end


njs50bot.getFullAndGo = function(roomNumber, cb)
  njs50bot.sleepUntilFull(function() 
    tfe.gotoRoom(roomNumber, function()
      if (cb) then cb() end
    end)
  end)
end


-- kills everything in the room! - this will probably get you dead
-- probably you should filter the list of things to kill and only kill specific mobs

njs50bot.killAll = function(cb)
  
  njs50bot.log('\n&lt;green&gt;njs50bot:&lt;white&gt; going to kill everything in this room...\n')
  
  local scanFailedTrigger, killNextScanHandler
  
  -- when we recieve new scan results, this is what we want to do:
  killNextScanHandler = njs50.onNextEvent(njs50.scanner.events.SCAN_PROCESSED, function()
    
    njs50bot.log('\n&lt;green&gt;njs50bot:&lt;white&gt; scan success\n')
    
    -- scan succeded so kill the scan fail trigger
    killTrigger(scanFailedTrigger);
    
    -- if nothing is left in the room invoke the callback
    if (not njs50.scanner.exits['[Here]'] or #njs50.scanner.exits['[Here]'] == 0) then
      njs50bot.log('\n&lt;green&gt;njs50bot:&lt;white&gt; kill all succeded\n')
      if (cb) then cb() end
    else
      
      -- pick the first thing on scan
      -- this list might need to be filtered for friendlies. i.e pets, group members
      local victim = njs50.scanner.exits['[Here]'][1].killString
      
      -- define these variables here so they are available inside all the functions we are about to make
      local victimMissingTrigger, noActionTimer, somethingDiedTrigger
      
      local cleanupTempThings = function()
        if (victimMissingTrigger) then killTrigger(victimMissingTrigger) end
        if (somethingDiedTrigger) then killTrigger(somethingDiedTrigger) end
        if (noActionTimer) then killTimer(noActionTimer) end
      end
      
      victimMissingTrigger = tempRegexTrigger([[(The room doesn't contain any beings|Nothing found) matching "]] .. victim .. [["\.$]], function()
        njs50bot.log('\n&lt;green&gt;njs50bot:&lt;white&gt; kill victim missing - scanning again in 5\n')
        -- failed to find/kill victim
        cleanupTempThings()
        tempTimer(5, function() njs50.killAll(cb) end)
      end, 1)
      
      somethingDiedTrigger = tempRegexTrigger([[You receive \d+ experience points\.$]], function()
        njs50bot.log('\n&lt;green&gt;njs50bot:&lt;white&gt; kill victim dead\n')
        -- failed to find/kill victim
        cleanupTempThings()
        njs50bot.killAll(cb)
      end, 1)
      
      noActionTimer = tempTimer(20, function()
        -- 20 seconds passed without anything dying or being not found. try scanning again
        njs50bot.log('\n&lt;green&gt;njs50bot:&lt;white&gt; kill all timed out, trying again\n')
        cleanupTempThings()
        njs50bot.killAll(cb)
      end)
      
      send('kill ' .. victim)
    end
    
  end)
  
  
  scanFailedTrigger = tempRegexTrigger([[The current battle has you occupied\.$]], function()
    
    njs50bot.log('\n&lt;green&gt;njs50bot:&lt;white&gt; kill all scan failed due to combat, trying again in 5\n')
    
    -- failed to scan due to combat, kill the handler for processing scan results
    killNextScanHandler()
    
    -- try again in 5 seconds
    tempTimer(5, function()
      njs50.killAll(cb)
    end)
    
  end, 1)
  

  murder.scan('kill all scan')

end

njs50bot.checkRepop = function (roomId, regex, callback) 

  local startRoomId = tfe.roomInfo.num
  
  local repopped = true
 
  local noRepopTrigger = tempRegexTrigger(regex, function () 
    repopped = false
  end, 1)

  -- go to the check room and back to the start 
  -- makesure timeout is long enough to do this.
  tfe.gotoRoom(roomId, function()
    tfe.gotoRoom(startRoomId, function()
    
      -- if trigger hasn't run then repop happened
      if (repopped) then
        killTrigger(noRepopTrigger)
        njs50bot.log('\n\n&lt;green&gt;-=[ repopped ]=-\n')
        callback()
      else
        -- no repop
        local delay = 12 + math.random (1,8)
        
        njs50bot.log('\n\n&lt;orange&gt;-=[ no repop, waiting ' .. tostring(delay) .. 's ]=-\n')
        
        tempTimer(delay, function () 
          njs50bot.checkRepop(roomId, regex, callback)
        end, 'repop check') 
             
      end
    
    end)
  end) 
  

  
end

-- runs a function at each step of a path, then the callback when complete
-- stepFn needs to call a callback when complete to invoke the next step

-- njs50bot.executePath({41750, 41751, 41756, 41758, 41753, 41752}, njs50.killAll, function() send('cheer') end)

njs50bot.executePath = function (path, stepFn, cb)
 -- 41750, 41751, 41756, 41758, 41753, 41752
  local currentStep = 0
  
  local stepper
  
  stepper = function()
    
    if (currentStep == #path) then
      
      cecho('\n&lt;green&gt;njs50bot:&lt;white&gt; reached end of path\n')
      if (cb) then cb() end
      
    else
    
      currentStep = currentStep + 1
      local destination = path[currentStep]
      cecho('\n&lt;green&gt;njs50bot:&lt;white&gt; going to ' .. tostring(destination) .. '\n')
      tfe.gotoRoom(destination, function()
        stepFn(stepper)
      end)
      
    end
    
  end
 
  stepper()
 
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>mansion.bot</name>
				<packageName></packageName>
				<script>njs50bot.mansion = function ()
    
  -- gets full then goes to repop then invokes the callback
  local gotoRepop = function(cb) 
    njs50bot.getFullAndGo(40582, cb) 
  end
  
  
  --  gets full, goes to room 41758, murders whatever is in the room, then invokes the callback
  local firstRoom = function(cb)
    njs50bot.getFullAndGo(41758, function()
      njs50bot.killAll(function()
        njs50bot.log('\n\n&lt;green&gt;SAMPLEBOT:&lt;white&gt; the first room is now clear!\n\n')
        -- we might want more custom code in here!
        cb()
      end)
    end) 
  end
 
  -- murders all the things in a room, then sleeps until full hp/mv/en before invoking callback.
  local genericRoomMurderAll = function(cb)
     njs50bot.killAll(function()
      njs50bot.sleepUntilFull(cb)
    end)  
  end

  
  local runComplete = function()
    njs50bot.log('\n\n&lt;green&gt;SAMPLEBOT:&lt;white&gt; mansion bot completed!\n\n')
    -- we might start the run again here if this was a real bot, mabye after some delay / loot sorting etc.
  end
  
  
  njs50bot.log('\n\n&lt;green&gt;SAMPLEBOT:&lt;white&gt; commencing mansion bot!\n\n')
  
  gotoRepop(function()
    
    njs50bot.checkRepop('41750', [[^\S+ \w+ coins? lies?]], function()
      
      -- manual first room
      firstRoom(function()
        
        -- generic path then goes through a list of rooms murdering everything then getting full hp etc before continuing
        njs50bot.executePath({41750, 41751, 41756, 41758, 41753, 41752}, genericRoomMurderAll, function() 
        
          -- leave a copper coin on the floor for the repop check
           tfe.gotoRoom(41750, function()
            send('drop copper.coin')
            
            -- go back to repop and run the run complete function
            gotoRepop(runComplete)
          end) 
                
        end) -- end execute path
        
      end) -- end first room
      
    end) -- end repop check
    
  end) -- end goto repop
  
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>gmcp-events</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>tfe.room_info_update</name>
				<packageName></packageName>
				<script>tfe = tfe or {}

tfe.consts = tfe.consts or {}

tfe.consts.exitmap = {
    n = 'north',    e = 'east',
    w = 'west',     s = 'south',
    u = 'up',       d = 'down',
	  N = 'north',    E = 'east',
    W = 'west',     S = 'south',
    U = 'up',       D = 'down',
    ["in"] = 'in',  out = 'out',
}


tfe.consts.short = {}
for k,v in pairs(tfe.consts.exitmap) do
    tfe.consts.short[v] = k
end

tfe.consts.standardExits = {
  north = true,
  east = true,
  south = true,
  west = true,
  up = true,
  down = true,
}

-- for some reason the speed walker doesn't use shorts for up/down
tfe.consts.exitmap['up'] = 'up'
tfe.consts.exitmap['down'] = 'down'

tfe.consts.stubmap = {
    north = 1,      east = 4,
    west = 5,       south = 6,
    up = 9,         down = 10,          
    ["in"] = 11,    out = 12,
    [1] = "north",  [4] = "east",
    [5] = "west",   [6] = "south",
    [9] = "up",     [10] = "down",
    [11] = "in",    [12] = "out",
}

-- in case an in/out goes to the same zone send it/down 100 layers so it doesn't overlap with an existing exit
tfe.consts.coordmap = {
    [1] = {0,1,0},      [4] = {1,0,0},
    [5] = {-1,0,0},     [6] = {0,-1,0},
    [9] = {0,0,1},      [10] = {0,0,-1},
    [11] = {0,0,100},     [12] = {0,0,-100}
}

tfe.consts.reverse_dirs = {
    north = "south", south = "north",
		west = "east", east = "west",
		up = "down", down = "up",
    ["in"] = "out", out = "in",
}

tfe.resetRoom = function ()
  tfe.roomInfo = gmcp.Room.Info
  tfe.previousRoomInfo = tfe.roomInfo
  tfe.lastMoveDirection = ''
end


tfe.room_info_update = function()
  
  local roomChanged = false
  
  -- only proceed if there is actually room info
  if (gmcp.Room.Info.area_id and gmcp.Room.Info.num) then
    
    if (tfe.roomInfo) then
    	
			-- if we changed rooms update lat move direction and previous room
			if (tfe.roomInfo.num ~= gmcp.Room.Info.num) then
			
        roomChanged = true
        
        -- reset the scanner as it's possible for a scan to be in progress while
        -- we are changing rooms.
        -- this happens if we have a move queued and the previous scan was waiting for
        -- and empty line/prompt to complete.
        
        -- i.e north: some stuff 
        -- &lt;gmcp room change due to queued move&gt;
        -- &lt;new line from gmcp update causes scan to complete&gt;
        if (njs50.scanner.scan_in_progress) then
          cecho('&lt;yellow&gt; &lt;--- &lt;white&gt;cleared in progress scan\n')
          njs50.scanner.resetScanner()
        end
        -- cecho('&lt;yellow&gt; &lt;--- #' .. tostring(gmcp.Room.Info.num) .. '\n')
      
        tfe.previousRoomInfo = tfe.roomInfo
        tfe.lastMoveDirection = ''
        
        if (tfe.previousRoomInfo.num and getRoomExits(tfe.previousRoomInfo.num)) then
          for exit, vnum in pairs(getRoomExits(tfe.previousRoomInfo.num)) do
            if (vnum == gmcp.Room.Info.num) then
              tfe.lastMoveDirection = exit
              break
            end
          end
        end
        
        if (tfe.lastMoveDirection == '') then
          for exit, vnum in pairs(tfe.roomInfo.exits) do
            if (vnum == tfe.roomInfo.num) then
              tfe.lastMoveDirection = tfe.consts.reverse_dirs[exit]
              break
            end
          end
        end
        
        -- if we are badly out of sync set the last room to this room
        -- if (tfe.lastMoveDirection == '') then
          -- tfe.previousRoomInfo = gmcp.Room.Info
          -- tfe.lastMoveDirection = ''
        -- end
        
			end -- end if this room is diff from the prev room info room

    else
    
      -- first room in this session, set some sane defaults for prev room / direction
      tfe.previousRoomInfo = gmcp.Room.Info
      tfe.lastMoveDirection = ''

    end -- end if has room info
    
    tfe.roomInfo = gmcp.Room.Info 
    
    local areaId = tfe.getAreaID(tfe.roomInfo)
    
    -- if existing room center map on it
    if (not roomExists(tfe.roomInfo.num)) then

      -- adding new room
      
      local x = 0; local y = 0; local z = 0;
      
      local foundAdjacent = false

      if (tfe.pendingExit ~= nil and not tfe.roomInfo.exits[tfe.pendingExit.direction]) then 
        -- display(tfe.roomInfo)
        cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; added special exit from the room ' .. tfe.pendingExit.direction .. '!\n')
        tfe.roomInfo.exits[tfe.pendingExit.direction] = tfe.pendingExit.vnum
      end


      -- look for an adjacent room
      for exit, vnum in pairs(tfe.roomInfo.exits) do
        
        if (roomExists(vnum)) then
        
      		x,y,z = tfe.getRoomCoordinatesByExit(vnum, tfe.consts.reverse_dirs[exit])
      		-- echo('\nlocation is: ' .. tostring(x) .. ', ' .. tostring(y) .. ', ' .. tostring(z) .. ')\n')
          foundAdjacent = true
          
          break;
        
        end
        
      end -- end looping over exits
      
      
      
      if (#getAreaRooms(areaId) &gt; 0 and not foundAdjacent) then
        cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt; no adjacent room known or other rooms exist in this map!\n')
        cecho('You can use the "map connect &lt;direction you just went : [n|e|s|w|u|d|in|out]&gt; &lt;command you used to get here&gt;" to connect this room\n\n')
        display(tfe.previousRoomInfo)
        return
      end

      -- echo('\nlocation is: (' .. tostring(x) .. ', ' .. tostring(y) .. ', ' .. tostring(z) .. ')\n')

      addRoom(tfe.roomInfo.num)
		  setRoomArea(tfe.roomInfo.num, areaId);
  	  setRoomName(tfe.roomInfo.num, tfe.roomInfo.name)
  	  setRoomCoordinates(tfe.roomInfo.num, x, y, z)

    end
    
    -- updating exiting room if we haven't been into it before
    -- we can tell because it won't have a name yet...
    if (tfe.roomInfo.name ~= getRoomName(tfe.roomInfo.num)) then
  	  setRoomName(tfe.roomInfo.num, tfe.roomInfo.name)
      -- clear the temp room env color (grey)
      setRoomWeight(tfe.roomInfo.num, 1)
    end
    
    -- fix any area id's that have been mutilated by previous mappers
    if (getRoomArea(tfe.roomInfo.num) ~= areaId) then
      setRoomArea(tfe.roomInfo.num, areaId);
    end
    
    
    -- check terrain in this room
    local terrain = tfe.environment[tfe.roomInfo.environment]
    
    if (not terrain) then
      cecho('\n&lt;red&gt;MAPPER:&lt;white&gt; missing terrain type! - ' .. tfe.roomInfo.environment .. '\n')
    end
    
    if (terrain and getRoomEnv(tfe.roomInfo.num) ~= terrain) then
      setRoomEnv(tfe.roomInfo.num, terrain)
    end
    

		-- update room exit stubs (may change w/secret doors etc)
    local existingExits = getRoomExits(tfe.roomInfo.num)
		
    for exit, exitInfo in pairs(tfe.roomInfo.exit_info) do
			if(not existingExits[exit] and tfe.consts.short[exit]) then
      	setExitStub(tfe.roomInfo.num, tfe.consts.short[exit], true)
        
        -- add in a temp room for any rooms we haven't visited yet
        if (not roomExists(exitInfo.num)) then
          addRoom(exitInfo.num)
          setRoomArea(exitInfo.num, tfe.getAreaID(exitInfo));
          setRoomEnv(exitInfo.num, 272)
          -- set high room weight so we won't auto walk through it unless absolutely necessary
          setRoomWeight(exitInfo.num, 100)
          
          local x,y,z = tfe.getRoomCoordinatesByExit(tfe.roomInfo.num, exit)
          -- echo('\nnew location is: ' .. tostring(x) .. ', ' .. tostring(y) .. ', ' .. tostring(z) .. ')\n')
          setRoomCoordinates(exitInfo.num, x, y, z)
        end
      
        -- cecho('\n&lt;green&gt;MAPPER: &lt;white&gt;joining ' .. tostring(tfe.roomInfo.num) ..' to room: ' .. tostring(vnum) .. ' - ' .. exit)
        setExit(tfe.roomInfo.num, exitInfo.num, tfe.consts.stubmap[exit])
        if (tfe.roomInfo.area == 'The Ways' and exitInfo.area ~= 'The Ways') then
          cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; not adding reverse connection to the ways\n')
        else
          setExit(exitInfo.num, tfe.roomInfo.num, tfe.consts.stubmap[tfe.consts.reverse_dirs[exit]])
        end
        
			end
    end -- end looping over exits
  
  	centerview(tfe.roomInfo.num)

    if (roomChanged == true) then
      tfe.roomInfo.scanned = false
      if (tfe.supressNextRoomChange) then
        tfe.supressNextRoomChange = nil
      else
        tempRegexTrigger([[^(\|      Exits:|\[Exits:|DARKNESS)]], function()
          cecho('&lt;green&gt; &lt;-- exit') 
          raiseEvent(tfe.events.ROOM_CHANGED, tfe.roomInfo)
        end, 1)        
      end
    end
 
  else
  
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt; gmcp room info missing area id or room number\n')
    display(gmcp.Room.Info)
    
  end
  
  
end

tfe.getRoomCoordinatesByExit = function (vnum, dir)

  local x,y,z = getRoomCoordinates(vnum);
	local dx, dy, dz = unpack(tfe.consts.coordmap[tfe.consts.stubmap[dir]])
  x = x + dx
  y = y + dy
  z = z + dz
  return x, y, z
  
end

tfe.getAreaID = function(roomInfo)
  
  if (not roomInfo.area or roomInfo.area == '') then
    -- display('weird room info: area = ' .. roomInfo.area .. ', id= ' .. tostring(roomInfo.area_id) )
    roomInfo.area = '???'
  end

  local area =  roomInfo.area .. ' : ' .. tostring(roomInfo.area_id)

	local areas = getAreaTable()
  
  if (areas[area]) then
    return areas[area]
  else
    cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;created new area: ' .. area .. '\n')
    return addAreaName(area)
  end

end

tfe.deleteCurrentMapArea = function ()
  
  local areaId = tfe.getAreaID(tfe.roomInfo)
  deleteArea(areaId)
  echo('\nRESET CURRENT AREA\n')
  updateMap()

end


tfe.deleteMapAreaByName = function (area)
    
  local areas = getAreaTable()  
  
  if (areas[area]) then  
    deleteArea(areas[area])
    echo('\nRESET AREA - ' .. area .. '\n')
    updateMap()
  end

end

tfe.deleteOrphanedRooms = function()
  
  for idx, val in ipairs(getAreaRooms(-1)) do
    deleteRoom(val)
  end

end

tfe.displayCurrentAreaExits = function ()
  
  local areaId = tfe.getAreaID(tfe.roomInfo)

  display( getAreaExits(areaId, true) )
  

end</script>
				<eventHandlerList>
					<string>gmcp.Room.Info</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>gmcp handling</name>
				<packageName></packageName>
				<script>njs50 = njs50 or {}

njs50.gmcp = njs50.gmcp or {}

njs50.gmcp.events = njs50.gmcp.events or {}

njs50.gmcp.events.ROOM_EXITS_UPDATE = "gmcp: room exits changed"

njs50.gmcp.previous = njs50.gmcp.previous or {}

njs50.gmcp.logLevel = 'errors'

njs50.recursiveDiff = function(t1, t2)
  -- display('comparing:', t1, t2)
  local diff = {}

  for idx, key in ipairs(table.keys(t1)) do
    
    if t2[key] ~= nil then  

      if (type(t1[key]) == 'table') then
        diff[key] = njs50.recursiveDiff(t1[key],t2[key])
      else
        if t2[key] ~= t1[key] then
          -- display(key, t2[key], t1[key])
          diff[key] = t2[key]
        end
      end

    else
      -- not in t2 at all
      diff[key] = table.deepcopy(t1[key])
    end
    
  end    
  
  -- anything left from t2
  for idx, key in ipairs(table.keys(t2)) do
    if (t1[key] == nil) then
      diff[key] = table.deepcopy(t2[key])
    end
  end
  
  if (#table.keys(diff) == 0) then
    return nil
  end
  
  return diff
  
end


njs50.tableHasValueChanges = function(t1, t2) 

  t1 = t1 or {}
  t2 = t2 or {}
  
  local td = njs50.recursiveDiff(t1, t2)

  if (njs50.gmcp.logLevel == 'debug') then
    cecho('\n&lt;yellow&gt;GMCP:&lt;white&gt; table diff:\n')
    display(td) 
    cecho('\n&lt;white&gt;-- end of diff\n')
  end
  
  return (td ~= nil)
  
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>njs50.room_info_update</name>
				<packageName></packageName>
				<script>

njs50.room_info_update = function()

  if (gmcp.Room.Info.num ~= njs50.gmcp.previous.roomNum) then
    njs50.gmcp.previous.roomNum = gmcp.Room.Info.num
  else
    
    -- only looking for exit info changes when the room hasn't changed!
    if (njs50.tableHasValueChanges(gmcp.Room.Info.exit_info, njs50.gmcp.previous.exitInfo)) then
      
      -- cecho('&lt;green&gt; &lt;-- exit info updated ')
      njs50.gmcp.previous.exitInfo = table.deepcopy(gmcp.Room.Info.exit_info)
      
      raiseEvent(njs50.gmcp.events.ROOM_EXITS_UPDATE)
      
    end

  end


end

</script>
				<eventHandlerList>
					<string>gmcp.Room.Info</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
